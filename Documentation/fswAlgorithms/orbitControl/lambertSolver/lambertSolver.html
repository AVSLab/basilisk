

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Module: lambertSolver &mdash; Basilisk 2.8.3
 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/custom.css?v=57a44e8a" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=5e07a493"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../../_static/copybutton.js?v=3cd7d658"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="_UnitTest" href="_UnitTest/index.html" />
    <link rel="prev" title="lambertSolver" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #CFB87C" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            Basilisk
              <img src="../../../../_static/Basilisk-Logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basilisk:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../Install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Learn.html">Learning Basilisk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Support.html">Support</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../index.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../../architecture/index.html">architecture</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html">fswAlgorithms</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../attControl/index.html">attControl</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../attDetermination/index.html">attDetermination</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../attGuidance/index.html">attGuidance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../dvGuidance/index.html">dvGuidance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../effectorInterfaces/index.html">effectorInterfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../formationFlying/index.html">formationFlying</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../fswUtilities/index.html">fswUtilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../imageProcessing/index.html">imageProcessing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../opticalNavigation/index.html">opticalNavigation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">orbitControl</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../lambertPlanner/index.html">lambertPlanner</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lambertSecondDV/index.html">lambertSecondDV</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="index.html">lambertSolver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lambertSurfaceRelativeVelocity/index.html">lambertSurfaceRelativeVelocity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lambertValidator/index.html">lambertValidator</a></li>
<li class="toctree-l4"><a class="reference internal" href="../smallBodyWaypointFeedback/index.html">smallBodyWaypointFeedback</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rwConfigData/index.html">rwConfigData</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../sensorInterfaces/index.html">sensorInterfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../smallBodyNavigation/index.html">smallBodyNavigation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../stateEstimation/index.html">stateEstimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../transDetermination/index.html">transDetermination</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../vehicleConfigData/index.html">vehicleConfigData</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../moduleTemplates/index.html">moduleTemplates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../simulation/index.html">simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../utilities/index.html">utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../supportData.html">Support Data Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ExternalSites.html">External Sites</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Vizard:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Vizard/Vizard.html">About Vizard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Vizard/VizardDownload.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Vizard/VizardReleaseNotes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Vizard/VizardGUI.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Vizard/vizardAdvanced/index.html">Advanced Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../Vizard/vizardGallery.html">Video Gallery</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #CFB87C" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Basilisk</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Documentation</a></li>
          <li class="breadcrumb-item"><a href="../../index.html">fswAlgorithms</a></li>
          <li class="breadcrumb-item"><a href="../index.html">orbitControl</a></li>
          <li class="breadcrumb-item"><a href="index.html">lambertSolver</a></li>
      <li class="breadcrumb-item active">Module: lambertSolver</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/Documentation/fswAlgorithms/orbitControl/lambertSolver/lambertSolver.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-lambertsolver">
<span id="lambertsolver"></span><h1>Module: lambertSolver<a class="headerlink" href="#module-lambertsolver" title="Link to this heading"></a></h1>
<section id="executive-summary">
<h2>Executive Summary<a class="headerlink" href="#executive-summary" title="Link to this heading"></a></h2>
<p>This module solves Lambert’s problem using either the <a class="reference external" href="https://doi.org/10.1007/BF00049511">algorithm by R.H. Gooding</a>
(longer, extensive report available <a class="reference external" href="https://apps.dtic.mil/sti/citations/ADA200383">here</a> ) or the
<a class="reference external" href="https://doi.org/10.1007/s10569-014-9587-y">algorithm by D. Izzo</a>. Given two position vectors <span class="math notranslate nohighlight">\(\mathbf{r}_{1}\)</span>
and <span class="math notranslate nohighlight">\(\mathbf{r}_{2}\)</span> as well as a requested time-of-flight <span class="math notranslate nohighlight">\(t\)</span>, the solution to Lambert’s problem provides
the corresponding velocity vectors v1_N and v2_N of the transfer orbit. The information about the type of algorithm
(Gooding or Izzo), the position vectors, the time-of-flight as well as the number of complete revolutions around the
central body, is provided by the <a class="reference internal" href="../../../architecture/msgPayloadDefC/LambertProblemMsgPayload.html#lambertproblemmsgpayload"><span class="std std-ref">LambertProblemMsgPayload</span></a> input message. The velocity vectors are computed in the
same frame as the input position vectors.</p>
<p>The algorithms by Gooding and Izzo provide solutions for elliptic, parabolic and hyperbolic transfer orbits.
In the zero-revolution case, exactly one solution exists. In the multi-revolution case (meaning that the transfer orbit
completes at least one complete revolution about the central body), either two or zero solutions exist, depending on
whether the requested transfer time is greater or less than the minimum time-of-flight for the given number of
revolutions. The <a class="reference internal" href="../../../architecture/msgPayloadDefC/LambertSolutionMsgPayload.html#lambertsolutionmsgpayload"><span class="std std-ref">LambertSolutionMsgPayload</span></a> output message includes two solutions. If a solution does not exist,
the corresponding velocity vectors in the message are equal to the zero vector, and the “validity” flag is equal to
zero. Otherwise, the “validity” flag is set to 1.</p>
</section>
<section id="message-connection-descriptions">
<h2>Message Connection Descriptions<a class="headerlink" href="#message-connection-descriptions" title="Link to this heading"></a></h2>
<p>The following table lists all the module input and output messages.
The module msg connection is set by the user from python.
The msg type contains a link to the message structure definition, while the description
provides information on what this message is used for.</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Module I/O Messages</span><a class="headerlink" href="#id1" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Msg Variable Name</p></th>
<th class="head"><p>Msg Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>lambertProblemInMsg</p></td>
<td><p><a class="reference internal" href="../../../architecture/msgPayloadDefC/LambertProblemMsgPayload.html#lambertproblemmsgpayload"><span class="std std-ref">LambertProblemMsgPayload</span></a></p></td>
<td><p>lambert problem setup input message</p></td>
</tr>
<tr class="row-odd"><td><p>lambertSolutionOutMsg</p></td>
<td><p><a class="reference internal" href="../../../architecture/msgPayloadDefC/LambertSolutionMsgPayload.html#lambertsolutionmsgpayload"><span class="std std-ref">LambertSolutionMsgPayload</span></a></p></td>
<td><p>lambert problem solution output message</p></td>
</tr>
<tr class="row-even"><td><p>lambertPerformanceOutMsg</p></td>
<td><p><a class="reference internal" href="../../../architecture/msgPayloadDefC/LambertPerformanceMsgPayload.html#lambertperformancemsgpayload"><span class="std std-ref">LambertPerformanceMsgPayload</span></a></p></td>
<td><p>lambert problem performance message (additional information about the solution process)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-assumptions-and-limitations">
<h2>Module Assumptions and Limitations<a class="headerlink" href="#module-assumptions-and-limitations" title="Link to this heading"></a></h2>
<p>The algorithms only compute solutions for a positive time-of-flight, and for positive transfer angles (meaning that the
true anomaly of <span class="math notranslate nohighlight">\(\mathbf{r}_{2}\)</span> is greater than the true anomaly of <span class="math notranslate nohighlight">\(\mathbf{r}_{1}\)</span>.</p>
<p>An edge case exists for a transfer angle of 0 or 180 degrees, as the two position vectors do not define a plane, so an
infinite number of solutions exist. The module checks if the angle between the two position vectors is smaller than the
threshold “alignmentThreshold”. In this case, the computed velocity vectors are set equal to the zero vector and the
validity flag of the solution is set to zero.</p>
<p>While the module also works for parabolic transfer orbits, the solutions for orbits that are very close to - but not
exactly - parabolic, may not be as accurate.</p>
</section>
<section id="user-guide">
<h2>User Guide<a class="headerlink" href="#user-guide" title="Link to this heading"></a></h2>
<p>The module is first initialized as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lambertModule</span> <span class="o">=</span> <span class="n">lambertSolver</span><span class="o">.</span><span class="n">LambertSolver</span><span class="p">()</span>
<span class="n">lambertModule</span><span class="o">.</span><span class="n">ModelTag</span> <span class="o">=</span> <span class="s2">&quot;lambertSolver&quot;</span>
<span class="n">lambertModule</span><span class="o">.</span><span class="n">setAlignmentThreshold</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="c1"># module defaults this value to 1.0 degrees if not specified</span>
<span class="n">unitTestSim</span><span class="o">.</span><span class="n">AddModelToTask</span><span class="p">(</span><span class="n">unitTaskName</span><span class="p">,</span> <span class="n">lambertModule</span><span class="p">)</span>
</pre></div>
</div>
<p>The lambert problem input message is either created as a standalone message in python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lambertProblemInMsgData</span> <span class="o">=</span> <span class="n">messaging</span><span class="o">.</span><span class="n">LambertProblemMsgPayload</span><span class="p">()</span>
<span class="n">lambertProblemInMsgData</span><span class="o">.</span><span class="n">solverMethod</span> <span class="o">=</span> <span class="n">messaging</span><span class="o">.</span><span class="n">IZZO</span>
<span class="n">lambertProblemInMsgData</span><span class="o">.</span><span class="n">r1_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">10000.</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="n">lambertProblemInMsgData</span><span class="o">.</span><span class="n">r2_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">8000.</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="n">lambertProblemInMsgData</span><span class="o">.</span><span class="n">transferTime</span> <span class="o">=</span> <span class="mf">10000.</span>
<span class="n">lambertProblemInMsgData</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="mf">3.986004418e14</span>
<span class="n">lambertProblemInMsgData</span><span class="o">.</span><span class="n">numRevolutions</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lambertProblemInMsg</span> <span class="o">=</span> <span class="n">messaging</span><span class="o">.</span><span class="n">LambertProblemMsg</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">lambertProblemInMsgData</span><span class="p">)</span>
</pre></div>
</div>
<p>or obtained from another FSW module. The lambert problem input message is then connected.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lambertModule</span><span class="o">.</span><span class="n">lambertProblemInMsg</span><span class="o">.</span><span class="n">subscribeTo</span><span class="p">(</span><span class="n">lambertProblemInMsg</span><span class="p">)</span>
</pre></div>
</div>
<hr class="docutils" />
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv413LambertSolver">
<span id="_CPPv313LambertSolver"></span><span id="_CPPv213LambertSolver"></span><span id="LambertSolver"></span><span class="target" id="class_lambert_solver"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">LambertSolver</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">public</span></span><span class="w"> </span><a class="reference internal" href="../../../architecture/_GeneralModuleFiles/sys_model.html#_CPPv48SysModel" title="SysModel"><span class="n"><span class="pre">SysModel</span></span></a><a class="headerlink" href="#_CPPv413LambertSolver" title="Link to this definition"></a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;lambertSolver.h&gt;</em></div>
<p>This module solves Lambert’s problem using either the Gooding or the Izzo algorithm. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver13LambertSolverEv">
<span id="_CPPv3N13LambertSolver13LambertSolverEv"></span><span id="_CPPv2N13LambertSolver13LambertSolverEv"></span><span id="LambertSolver::LambertSolver"></span><span class="target" id="class_lambert_solver_1ab2ca50127ad0a6f153ee6870590d494f"></span><span class="sig-name descname"><span class="n"><span class="pre">LambertSolver</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver13LambertSolverEv" title="Link to this definition"></a><br /></dt>
<dd><p>This is the constructor for the module class. It sets default variable values and initializes the various parts of the model </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolverD0Ev">
<span id="_CPPv3N13LambertSolverD0Ev"></span><span id="_CPPv2N13LambertSolverD0Ev"></span><span id="LambertSolver::~LambertSolver"></span><span class="target" id="class_lambert_solver_1a3163b5eaaab081015824f02a9991221c"></span><span class="sig-name descname"><span class="n"><span class="pre">~LambertSolver</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolverD0Ev" title="Link to this definition"></a><br /></dt>
<dd><p>Module Destructor </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver5ResetE8uint64_t">
<span id="_CPPv3N13LambertSolver5ResetE8uint64_t"></span><span id="_CPPv2N13LambertSolver5ResetE8uint64_t"></span><span id="LambertSolver::Reset__uint64_t"></span><span class="target" id="class_lambert_solver_1a6030bc30cff04aec0da8993c5539a092"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Reset</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">currentSimNanos</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver5ResetE8uint64_t" title="Link to this definition"></a><br /></dt>
<dd><p>This method is used to reset the module and checks that required input messages are connected. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>currentSimNanos</strong> – current simulation time in nano-seconds </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver11UpdateStateE8uint64_t">
<span id="_CPPv3N13LambertSolver11UpdateStateE8uint64_t"></span><span id="_CPPv2N13LambertSolver11UpdateStateE8uint64_t"></span><span id="LambertSolver::UpdateState__uint64_t"></span><span class="target" id="class_lambert_solver_1a87046f06feafb8fb55facbc6d4160ac1"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UpdateState</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">currentSimNanos</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver11UpdateStateE8uint64_t" title="Link to this definition"></a><br /></dt>
<dd><p>This is the main method that gets called every time the module is updated. It computes the solution of Lambert’s problem. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>currentSimNanos</strong> – current simulation time in nano-seconds </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver21setAlignmentThresholdEKd">
<span id="_CPPv3N13LambertSolver21setAlignmentThresholdEKd"></span><span id="_CPPv2N13LambertSolver21setAlignmentThresholdEKd"></span><span id="LambertSolver::setAlignmentThreshold__doubleC"></span><span class="target" id="class_lambert_solver_1aeee211e313362c589ca46d44c3257c24"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">setAlignmentThreshold</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver21setAlignmentThresholdEKd" title="Link to this definition"></a><br /></dt>
<dd><p>setter for <code class="docutils literal notranslate"><span class="pre">alignmentThreshold</span></code></p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK13LambertSolver20getlignmentThresholdEv">
<span id="_CPPv3NK13LambertSolver20getlignmentThresholdEv"></span><span id="_CPPv2NK13LambertSolver20getlignmentThresholdEv"></span><span id="LambertSolver::getlignmentThresholdC"></span><span class="target" id="class_lambert_solver_1af982689e293c9e07d8b94cdf37802740"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">getlignmentThreshold</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK13LambertSolver20getlignmentThresholdEv" title="Link to this definition"></a><br /></dt>
<dd><p>getter for <code class="docutils literal notranslate"><span class="pre">alignmentThreshold</span></code></p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver19lambertProblemInMsgE">
<span id="_CPPv3N13LambertSolver19lambertProblemInMsgE"></span><span id="_CPPv2N13LambertSolver19lambertProblemInMsgE"></span><span id="LambertSolver::lambertProblemInMsg__ReadFunctor:LambertProblemMsgPayload:"></span><span class="target" id="class_lambert_solver_1a65e256826ade7e72b644c13955ebd81b"></span><a class="reference internal" href="../../../architecture/messaging/messaging.html#_CPPv4I0E11ReadFunctor" title="ReadFunctor"><span class="n"><span class="pre">ReadFunctor</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="../../../architecture/msgPayloadDefC/LambertProblemMsgPayload.html#_CPPv424LambertProblemMsgPayload" title="LambertProblemMsgPayload"><span class="n"><span class="pre">LambertProblemMsgPayload</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lambertProblemInMsg</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver19lambertProblemInMsgE" title="Link to this definition"></a><br /></dt>
<dd><p>lambert problem input message </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver21lambertSolutionOutMsgE">
<span id="_CPPv3N13LambertSolver21lambertSolutionOutMsgE"></span><span id="_CPPv2N13LambertSolver21lambertSolutionOutMsgE"></span><span id="LambertSolver::lambertSolutionOutMsg__Message:LambertSolutionMsgPayload:"></span><span class="target" id="class_lambert_solver_1a57596975cc39596dc6ded994bac38632"></span><a class="reference internal" href="../../../architecture/messaging/messaging.html#_CPPv4I0E7Message" title="Message"><span class="n"><span class="pre">Message</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="../../../architecture/msgPayloadDefC/LambertSolutionMsgPayload.html#_CPPv425LambertSolutionMsgPayload" title="LambertSolutionMsgPayload"><span class="n"><span class="pre">LambertSolutionMsgPayload</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lambertSolutionOutMsg</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver21lambertSolutionOutMsgE" title="Link to this definition"></a><br /></dt>
<dd><p>lambert solution output message </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver24lambertPerformanceOutMsgE">
<span id="_CPPv3N13LambertSolver24lambertPerformanceOutMsgE"></span><span id="_CPPv2N13LambertSolver24lambertPerformanceOutMsgE"></span><span id="LambertSolver::lambertPerformanceOutMsg__Message:LambertPerformanceMsgPayload:"></span><span class="target" id="class_lambert_solver_1a2bd0c14971cb1aaea8e69ee2ee034a6d"></span><a class="reference internal" href="../../../architecture/messaging/messaging.html#_CPPv4I0E7Message" title="Message"><span class="n"><span class="pre">Message</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="../../../architecture/msgPayloadDefC/LambertPerformanceMsgPayload.html#_CPPv428LambertPerformanceMsgPayload" title="LambertPerformanceMsgPayload"><span class="n"><span class="pre">LambertPerformanceMsgPayload</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lambertPerformanceOutMsg</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver24lambertPerformanceOutMsgE" title="Link to this definition"></a><br /></dt>
<dd><p>lambert performance output message </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver9bskLoggerE">
<span id="_CPPv3N13LambertSolver9bskLoggerE"></span><span id="_CPPv2N13LambertSolver9bskLoggerE"></span><span id="LambertSolver::bskLogger__BSKLogger"></span><span class="target" id="class_lambert_solver_1affc3118b43e3d8a7ea70f9976f23efdd"></span><span class="n"><span class="pre">BSKLogger</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bskLogger</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver9bskLoggerE" title="Link to this definition"></a><br /></dt>
<dd><p>BSK Logging. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-private-functions">Private Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver12readMessagesEv">
<span id="_CPPv3N13LambertSolver12readMessagesEv"></span><span id="_CPPv2N13LambertSolver12readMessagesEv"></span><span id="LambertSolver::readMessages"></span><span class="target" id="class_lambert_solver_1a9a51882655d1485e3dd81777682bd0ef"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readMessages</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver12readMessagesEv" title="Link to this definition"></a><br /></dt>
<dd><p>This method reads the input messages each call of updateState. It also checks if the message contents are valid for this module. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver13writeMessagesE8uint64_t">
<span id="_CPPv3N13LambertSolver13writeMessagesE8uint64_t"></span><span id="_CPPv2N13LambertSolver13writeMessagesE8uint64_t"></span><span id="LambertSolver::writeMessages__uint64_t"></span><span class="target" id="class_lambert_solver_1adb9ecd1e896c6dc6e140de3b170b4f77"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writeMessages</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">currentSimNanos</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver13writeMessagesE8uint64_t" title="Link to this definition"></a><br /></dt>
<dd><p>This method writes the output messages each call of updateState </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>currentSimNanos</strong> – current simulation time in nano-seconds </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver15problemGeometryEv">
<span id="_CPPv3N13LambertSolver15problemGeometryEv"></span><span id="_CPPv2N13LambertSolver15problemGeometryEv"></span><span id="LambertSolver::problemGeometry"></span><span class="target" id="class_lambert_solver_1ad051a1069dc836b566cb589bcb2ec07e"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">problemGeometry</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver15problemGeometryEv" title="Link to this definition"></a><br /></dt>
<dd><p>This method computes the problem geometry for the given parameters of Lambert’s problem. The orbit frame is also determined. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver19goodingInitialGuessEdd">
<span id="_CPPv3N13LambertSolver19goodingInitialGuessEdd"></span><span id="_CPPv2N13LambertSolver19goodingInitialGuessEdd"></span><span id="LambertSolver::goodingInitialGuess__double.double"></span><span class="target" id="class_lambert_solver_1a076e2aaafe4aa2f2f6766b0a1eeffd5a"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">double</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">goodingInitialGuess</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">T</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver19goodingInitialGuessEdd" title="Link to this definition"></a><br /></dt>
<dd><p>This method computes the initial guess for the free variable x using the Gooding procedure </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lam</strong> – lambda parameter that defines the problem geometry </p></li>
<li><p><strong>T</strong> – non-dimensional time-of-flight </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>std::array&lt;double, 2&gt; </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver16izzoInitialGuessEdd">
<span id="_CPPv3N13LambertSolver16izzoInitialGuessEdd"></span><span id="_CPPv2N13LambertSolver16izzoInitialGuessEdd"></span><span id="LambertSolver::izzoInitialGuess__double.double"></span><span class="target" id="class_lambert_solver_1a81b811efd2d64596dd61c01a59b998a7"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">double</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">izzoInitialGuess</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lambda</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">T</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver16izzoInitialGuessEdd" title="Link to this definition"></a><br /></dt>
<dd><p>This method computes the initial guess for the free variable x using the Izzo procedure </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lam</strong> – lambda parameter that defines the problem geometry </p></li>
<li><p><strong>T</strong> – non-dimensional time-of-flight </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>std::array&lt;double, 2&gt; </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver5findxEv">
<span id="_CPPv3N13LambertSolver5findxEv"></span><span id="_CPPv2N13LambertSolver5findxEv"></span><span id="LambertSolver::findx"></span><span class="target" id="class_lambert_solver_1a3bb0c64ce926a65b0244c671f8b5f7c6"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">findx</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver5findxEv" title="Link to this definition"></a><br /></dt>
<dd><p>This method finds the free variable x that satisfies the requested time of flight TOF. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver17computeVelocitiesEd">
<span id="_CPPv3N13LambertSolver17computeVelocitiesEd"></span><span id="_CPPv2N13LambertSolver17computeVelocitiesEd"></span><span id="LambertSolver::computeVelocities__double"></span><span class="target" id="class_lambert_solver_1ac19e42156a870762ba2120baee18d45d"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="../../../simulation/mujocoDynamics/_GeneralModuleFiles/MJSpec.html#_CPPv45Eigen" title="Eigen"><span class="n"><span class="pre">Eigen</span></span></a><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">Vector3d</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">computeVelocities</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver17computeVelocitiesEd" title="Link to this definition"></a><br /></dt>
<dd><p>This method computes the velocities at the initial and final position for a given free variable x </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> – free variable of Lambert’s problem that satisfies the given time of flight </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>std::array&lt;Eigen::Vector3d, 2&gt; </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver5x2tofEdid">
<span id="_CPPv3N13LambertSolver5x2tofEdid"></span><span id="_CPPv2N13LambertSolver5x2tofEdid"></span><span id="LambertSolver::x2tof__double.i.double"></span><span class="target" id="class_lambert_solver_1a5fab3b6e7fe054afdaf0bf236344b74b"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">x2tof</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">x</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">N</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lam</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver5x2tofEdid" title="Link to this definition"></a><br /></dt>
<dd><p>This method computes the non-dimensional time of flight (TOF) for a given x </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – free variable of Lambert’s problem that satisfies the given time of flight </p></li>
<li><p><strong>N</strong> – number of revolutions </p></li>
<li><p><strong>lam</strong> – lambda parameter that defines the problem geometry </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>double </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver4dTdxEddd">
<span id="_CPPv3N13LambertSolver4dTdxEddd"></span><span id="_CPPv2N13LambertSolver4dTdxEddd"></span><span id="LambertSolver::dTdx__double.double.double"></span><span class="target" id="class_lambert_solver_1a1d101f94f337abcc8319a23c4b8ce12f"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">double</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dTdx</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">T</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lam</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver4dTdxEddd" title="Link to this definition"></a><br /></dt>
<dd><p>This method computes the derivatives of the time of flight curve T(x) </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – free variable of Lambert’s problem that satisfies the given time of flight </p></li>
<li><p><strong>T</strong> – requested non-dimensional time-of-flight </p></li>
<li><p><strong>lam</strong> – lambda parameter that defines the problem geometry </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>std::array&lt;double, 3&gt; </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver11householderEddi">
<span id="_CPPv3N13LambertSolver11householderEddi"></span><span id="_CPPv2N13LambertSolver11householderEddi"></span><span id="LambertSolver::householder__double.double.i"></span><span class="target" id="class_lambert_solver_1a3adf64ad93040d69c111bf4714bc789c"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">double</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">householder</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">T</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">x0</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver11householderEddi" title="Link to this definition"></a><br /></dt>
<dd><p>This method includes a 3rd order householder root-finder to find the free variable x that satisfies the time-of-flight constraint. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> – requested non-dimensional time-of-flight </p></li>
<li><p><strong>x0</strong> – initial guess for x free variable of Lambert’s problem that satisfies the given time of flight </p></li>
<li><p><strong>N</strong> – number of revolutions </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>std::array&lt;double, 3&gt; </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver6halleyEddi">
<span id="_CPPv3N13LambertSolver6halleyEddi"></span><span id="_CPPv2N13LambertSolver6halleyEddi"></span><span id="LambertSolver::halley__double.double.i"></span><span class="target" id="class_lambert_solver_1ab0c2b0e46449d45f5e0b81921bb2b281"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">&lt;</span></span><span class="kt"><span class="pre">double</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">halley</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">T</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">x0</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver6halleyEddi" title="Link to this definition"></a><br /></dt>
<dd><p>This method includes a halley root-finder (2nd order householder) to find the free variable x that satisfies the time-of-flight constraint </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> – requested non-dimensional time-of-flight </p></li>
<li><p><strong>x0</strong> – initial guess for x free variable of Lambert’s problem that satisfies the given time of flight </p></li>
<li><p><strong>N</strong> – number of revolutions </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>std::array&lt;double, 3&gt; </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver7getTminEdi">
<span id="_CPPv3N13LambertSolver7getTminEdi"></span><span id="_CPPv2N13LambertSolver7getTminEdi"></span><span id="LambertSolver::getTmin__double.i"></span><span class="target" id="class_lambert_solver_1a78530e034d76a4c884b5e137e3ef7185"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">getTmin</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">T0M</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver7getTminEdi" title="Link to this definition"></a><br /></dt>
<dd><p>This method computes the minimum non-dimensional time-of-flight Tmin such that solutions exist for the multi-revolution case using a halley root-finder </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T0M</strong> – initial guess for Tmin </p></li>
<li><p><strong>N</strong> – number of revolutions </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>double </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver15hypergeometricFEd">
<span id="_CPPv3N13LambertSolver15hypergeometricFEd"></span><span id="_CPPv2N13LambertSolver15hypergeometricFEd"></span><span id="LambertSolver::hypergeometricF__double"></span><span class="target" id="class_lambert_solver_1a8c00162ffd3e5dda5bb7e91c391288ac"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hypergeometricF</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">z</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13LambertSolver15hypergeometricFEd" title="Link to this definition"></a><br /></dt>
<dd><p>This method computes the hypergeometric function 2F1(a,b,c,z) </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>z</strong> – argument of hypergeometric function </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>double </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-private-members">Private Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver18alignmentThresholdE">
<span id="_CPPv3N13LambertSolver18alignmentThresholdE"></span><span id="_CPPv2N13LambertSolver18alignmentThresholdE"></span><span id="LambertSolver::alignmentThreshold__double"></span><span class="target" id="class_lambert_solver_1a61dc3066cb543129dbffb6754a63dd48"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alignmentThreshold</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">1.0</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver18alignmentThresholdE" title="Link to this definition"></a><br /></dt>
<dd><p>[deg] minimum angle between position vectors so they are not too aligned. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver12solverMethodE">
<span id="_CPPv3N13LambertSolver12solverMethodE"></span><span id="_CPPv2N13LambertSolver12solverMethodE"></span><span id="LambertSolver::solverMethod__SolverMethod"></span><span class="target" id="class_lambert_solver_1aa5185a3fa447bc5d79f40e827d5a08f1"></span><a class="reference internal" href="../../../architecture/msgPayloadDefC/LambertProblemMsgPayload.html#_CPPv412SolverMethod" title="SolverMethod"><span class="n"><span class="pre">SolverMethod</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">solverMethod</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver12solverMethodE" title="Link to this definition"></a><br /></dt>
<dd><p>lambert solver algorithm (GOODING or IZZO) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver4r1_NE">
<span id="_CPPv3N13LambertSolver4r1_NE"></span><span id="_CPPv2N13LambertSolver4r1_NE"></span><span id="LambertSolver::r1_N__Eigen::Vector3d"></span><span class="target" id="class_lambert_solver_1a16e50d2a8ba486d74d80bf40a88e1881"></span><a class="reference internal" href="../../../simulation/mujocoDynamics/_GeneralModuleFiles/MJSpec.html#_CPPv45Eigen" title="Eigen"><span class="n"><span class="pre">Eigen</span></span></a><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">Vector3d</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">r1_N</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver4r1_NE" title="Link to this definition"></a><br /></dt>
<dd><p>position vector at t0 </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver4r2_NE">
<span id="_CPPv3N13LambertSolver4r2_NE"></span><span id="_CPPv2N13LambertSolver4r2_NE"></span><span id="LambertSolver::r2_N__Eigen::Vector3d"></span><span class="target" id="class_lambert_solver_1ab1ba1d1fbf319b58bcebb79971d51e49"></span><a class="reference internal" href="../../../simulation/mujocoDynamics/_GeneralModuleFiles/MJSpec.html#_CPPv45Eigen" title="Eigen"><span class="n"><span class="pre">Eigen</span></span></a><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">Vector3d</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">r2_N</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver4r2_NE" title="Link to this definition"></a><br /></dt>
<dd><p>position vector at t1 </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver12transferTimeE">
<span id="_CPPv3N13LambertSolver12transferTimeE"></span><span id="_CPPv2N13LambertSolver12transferTimeE"></span><span id="LambertSolver::transferTime__double"></span><span class="target" id="class_lambert_solver_1adcd8dd98ba78da0f9cb7b09ddf91c937"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">transferTime</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver12transferTimeE" title="Link to this definition"></a><br /></dt>
<dd><p>time of flight between r1_N and r2_N (t1-t0) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver2muE">
<span id="_CPPv3N13LambertSolver2muE"></span><span id="_CPPv2N13LambertSolver2muE"></span><span id="LambertSolver::mu__double"></span><span class="target" id="class_lambert_solver_1ae70987015e5f436bf272b7a5dffa4bc1"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mu</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver2muE" title="Link to this definition"></a><br /></dt>
<dd><p>gravitational parameter </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver19numberOfRevolutionsE">
<span id="_CPPv3N13LambertSolver19numberOfRevolutionsE"></span><span id="_CPPv2N13LambertSolver19numberOfRevolutionsE"></span><span id="LambertSolver::numberOfRevolutions__i"></span><span class="target" id="class_lambert_solver_1a9e30b5edc4dc6303f70af26724aec466"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numberOfRevolutions</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver19numberOfRevolutionsE" title="Link to this definition"></a><br /></dt>
<dd><p>number of revolutions </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver3TOFE">
<span id="_CPPv3N13LambertSolver3TOFE"></span><span id="_CPPv2N13LambertSolver3TOFE"></span><span id="LambertSolver::TOF__double"></span><span class="target" id="class_lambert_solver_1ae573396421f4f26c23c98dfe37ac9dde"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">TOF</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver3TOFE" title="Link to this definition"></a><br /></dt>
<dd><p>non-dimensional time-of-flight constraint </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver6lambdaE">
<span id="_CPPv3N13LambertSolver6lambdaE"></span><span id="_CPPv2N13LambertSolver6lambdaE"></span><span id="LambertSolver::lambda__double"></span><span class="target" id="class_lambert_solver_1afd7af25ff4b317ceefd4e1ccfdbc88c3"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lambda</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver6lambdaE" title="Link to this definition"></a><br /></dt>
<dd><p>parameter of Lambert”s problem that defines problem geometry </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver16multiRevSolutionE">
<span id="_CPPv3N13LambertSolver16multiRevSolutionE"></span><span id="_CPPv2N13LambertSolver16multiRevSolutionE"></span><span id="LambertSolver::multiRevSolution__b"></span><span class="target" id="class_lambert_solver_1a1b83894374109e2dae8b4e3226f11812"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">multiRevSolution</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver16multiRevSolutionE" title="Link to this definition"></a><br /></dt>
<dd><p>boolean flag if multi-revolution solutions exist or not </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver10noSolutionE">
<span id="_CPPv3N13LambertSolver10noSolutionE"></span><span id="_CPPv2N13LambertSolver10noSolutionE"></span><span id="LambertSolver::noSolution__b"></span><span class="target" id="class_lambert_solver_1a8fd484207a95ef9fc89b8c565af8fe68"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">noSolution</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver10noSolutionE" title="Link to this definition"></a><br /></dt>
<dd><p>boolean flag if no solution should be returned (in case of 180 deg transfer angle) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver7Oframe1E">
<span id="_CPPv3N13LambertSolver7Oframe1E"></span><span id="_CPPv2N13LambertSolver7Oframe1E"></span><span id="LambertSolver::Oframe1__std::array:Eigen::Vector3d.3:"></span><span class="target" id="class_lambert_solver_1a1cbb0a22ca7d2fe9740e47601bd656a3"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="../../../simulation/mujocoDynamics/_GeneralModuleFiles/MJSpec.html#_CPPv45Eigen" title="Eigen"><span class="n"><span class="pre">Eigen</span></span></a><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">Vector3d</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Oframe1</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver7Oframe1E" title="Link to this definition"></a><br /></dt>
<dd><p>array containing the orbit frame unit vectors at t0 </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver7Oframe2E">
<span id="_CPPv3N13LambertSolver7Oframe2E"></span><span id="_CPPv2N13LambertSolver7Oframe2E"></span><span id="LambertSolver::Oframe2__std::array:Eigen::Vector3d.3:"></span><span class="target" id="class_lambert_solver_1a9deffec3c54b1054a6615cfccd02f551"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="../../../simulation/mujocoDynamics/_GeneralModuleFiles/MJSpec.html#_CPPv45Eigen" title="Eigen"><span class="n"><span class="pre">Eigen</span></span></a><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">Vector3d</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Oframe2</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver7Oframe2E" title="Link to this definition"></a><br /></dt>
<dd><p>array containing the orbit frame unit vectors at t1 </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver5vvecsE">
<span id="_CPPv3N13LambertSolver5vvecsE"></span><span id="_CPPv2N13LambertSolver5vvecsE"></span><span id="LambertSolver::vvecs__std::array:Eigen::Vector3d.2:"></span><span class="target" id="class_lambert_solver_1a841e7ca22f54ea26b81b1a8e2e734805"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="../../../simulation/mujocoDynamics/_GeneralModuleFiles/MJSpec.html#_CPPv45Eigen" title="Eigen"><span class="n"><span class="pre">Eigen</span></span></a><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">Vector3d</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vvecs</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver5vvecsE" title="Link to this definition"></a><br /></dt>
<dd><p>array containing the velocity vector solutions at t0 and t1 </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver9vvecsSol2E">
<span id="_CPPv3N13LambertSolver9vvecsSol2E"></span><span id="_CPPv2N13LambertSolver9vvecsSol2E"></span><span id="LambertSolver::vvecsSol2__std::array:Eigen::Vector3d.2:"></span><span class="target" id="class_lambert_solver_1aa2206848ce32767e25164dc9f5898b5e"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="../../../simulation/mujocoDynamics/_GeneralModuleFiles/MJSpec.html#_CPPv45Eigen" title="Eigen"><span class="n"><span class="pre">Eigen</span></span></a><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">Vector3d</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vvecsSol2</span></span></span><a class="headerlink" href="#_CPPv4N13LambertSolver9vvecsSol2E" title="Link to this definition"></a><br /></dt>
<dd><p>array containing the velocity vector solutions at t0 and t1 (sol 2) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver1XE">
<span id="_CPPv3N13LambertSolver1XE"></span><span id="_CPPv2N13LambertSolver1XE"></span><span id="LambertSolver::X__double"></span><span class="target" id="class_lambert_solver_1a45b268fe73146890496ac96585a54983"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">X</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver1XE" title="Link to this definition"></a><br /></dt>
<dd><p>solution for free variable of Lambert’s problem </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver5XSol2E">
<span id="_CPPv3N13LambertSolver5XSol2E"></span><span id="_CPPv2N13LambertSolver5XSol2E"></span><span id="LambertSolver::XSol2__double"></span><span class="target" id="class_lambert_solver_1af00ee9f184c09d9eca9b144c67232cfb"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">XSol2</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver5XSol2E" title="Link to this definition"></a><br /></dt>
<dd><p>second solution for free variable of Lambert’s problem </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver7numIterE">
<span id="_CPPv3N13LambertSolver7numIterE"></span><span id="_CPPv2N13LambertSolver7numIterE"></span><span id="LambertSolver::numIter__i"></span><span class="target" id="class_lambert_solver_1aa13bd7d183d097049ebc3a58efe552f7"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numIter</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver7numIterE" title="Link to this definition"></a><br /></dt>
<dd><p>number of root finder iterations to find X </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver11numIterSol2E">
<span id="_CPPv3N13LambertSolver11numIterSol2E"></span><span id="_CPPv2N13LambertSolver11numIterSol2E"></span><span id="LambertSolver::numIterSol2__i"></span><span class="target" id="class_lambert_solver_1a69f25b10c92e6dde07a2ff095ec07f8c"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numIterSol2</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver11numIterSol2E" title="Link to this definition"></a><br /></dt>
<dd><p>number of root finder iterations to find X_sol2 </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver4errXE">
<span id="_CPPv3N13LambertSolver4errXE"></span><span id="_CPPv2N13LambertSolver4errXE"></span><span id="LambertSolver::errX__double"></span><span class="target" id="class_lambert_solver_1a0bc9c8ae12e7d8f12612c98ec730f291"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">errX</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver4errXE" title="Link to this definition"></a><br /></dt>
<dd><p>difference in X between last and second-to-last iteration </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N13LambertSolver8errXSol2E">
<span id="_CPPv3N13LambertSolver8errXSol2E"></span><span id="_CPPv2N13LambertSolver8errXSol2E"></span><span id="LambertSolver::errXSol2__double"></span><span class="target" id="class_lambert_solver_1a0dd3b12d46de5eb73899c9b9459bc296"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">errXSol2</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N13LambertSolver8errXSol2E" title="Link to this definition"></a><br /></dt>
<dd><p>difference in X between last and second-to-last iteration (for X_sol2) </p>
</dd></dl>

</div>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="lambertSolver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="_UnitTest/index.html" class="btn btn-neutral float-right" title="_UnitTest" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Autonomous Vehicle Systems (AVS) Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>