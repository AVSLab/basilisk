cmake_minimum_required(VERSION 2.8)
if(POLICY CMP0078)
  cmake_policy(SET CMP0078 NEW)
endif()
if(POLICY CMP0025)
  cmake_policy(SET CMP0025 NEW)
endif()
if(POLICY CMP0057)
  cmake_policy(SET CMP0057 NEW)
endif()

if(POLICY CMP0086)
  cmake_policy(SET CMP0086 NEW)
endif()

if(POLICY CMP0068)
  cmake_policy(SET CMP0068 NEW)
endif()

if(POLICY CMP0046)
  cmake_policy(SET CMP0046 NEW)
endif()

project("basilisk")

if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE "Debug" CACHE STRING
      "Choose the type of build, options are: Debug Release RelWithDebInfo MinSizeRel." FORCE)
endif(NOT CMAKE_BUILD_TYPE)

list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")




include(conan)
conan_add_remote(NAME conan-community URL https://api.bintray.com/conan/conan-community/conan)
conan_add_remote(NAME bincrafters URL https://api.bintray.com/conan/bincrafters/public-conan)

set(required_conan_libraries eigen/3.3.7@conan/stable)

# This appears to be temporarily nessesary until the new conan center libsodium is ready
list(APPEND required_conan_libraries libsodium/1.0.18@bincrafters/stable)


option(USE_PROTOBUFFERS "Include modules which use Google Protobuffers" ON)
option(USE_OPENCV "Include modules which use OpenCV" OFF)
option(USE_ZMQ "Include modules which use ZMQ" ON)
option(USE_PYTHON3 "Build For Python 3" ON)

set(requires_protobuff_modules "vizard/vizInterface/vizInterface.i")
set(requires_zmq_modules "vizard/vizInterface/vizInterface.i")


set(requires_opencv_modules "imageProcessing/houghCircles/houghCircles.i")
list(APPEND requires_opencv_modules "imageProcessing/limbFinding/limbFinding.i")
list(APPEND requires_opencv_modules "sensors/camera/camera.i")

set(requires_vulkan_modules "dynamics/SphericalHarmonicsSolvers/sphericalHarmonicsGPU/sphericalHarmonicsGPU.i"  "dynamics/SphericalHarmonicsSolvers/sphericalHarmonicsCPU/sphericalHarmonicsCPU.i")


if(USE_PROTOBUFFERS)
  list(APPEND required_conan_libraries protobuf/3.5.2@bincrafters/stable)
endif()
if(USE_OPENCV )
  list(APPEND required_conan_libraries opencv/4.1.1@conan/stable)
  # temp bug fix for bad pcre dependancies
  list(APPEND required_conan_libraries zlib/1.2.11@conan/stable)
  list(APPEND required_conan_libraries bzip2/1.0.8@conan/stable)
endif()

if(USE_ZMQ)
  list(APPEND required_conan_libraries cppzmq/4.3.0@bincrafters/stable)
endif()

conan_cmake_run(REQUIRES ${required_conan_libraries}
                OPTIONS opencv:contrib=True
	              BASIC_SETUP KEEP_RPATHS
                BUILD missing )

if(USE_PROTOBUFFERS)
   #! PROTO-BUFFERS
   find_package(protobuf CONFIG REQUIRED)
   message(STATUS "Using Protocol Buffers ${protobuf_VERSION}")
   set(CMAKE_INCLUDE_CURRENT_DIR TRUE)
endif()

if(USE_OPENCV)
   #! OPEN_CV
   #find_package(opencv CONFIG REQUIRED)
   message(STATUS "Using OpenCV ${opencv_VERSION}")
   set(CMAKE_INCLUDE_CURRENT_DIR TRUE)
   if(APPLE)
     link_libraries("-framework OpenCL")
   endif()
endif()

if(USE_ZMQ)
   #! USE_ZMQ
   find_package(cppzmq CONFIG REQUIRED)
   message(STATUS "Using ZMQ ${cppzmq_VERSION}")
   set(CMAKE_INCLUDE_CURRENT_DIR TRUE)
endif()


# HACK: Create Release and Debug directories for conan
# Conan hasn't fixed this issue yet, this removes warnings

foreach (library ${CONAN_LIB_DIRS})
   file(MAKE_DIRECTORY "${library}/Release")
   file(MAKE_DIRECTORY "${library}/Debug")
endforeach(library)


# Create a Swig module
# Avoids a deprecation error in CMAKE versions less than 3 by calling the correct API depending on version
# swig_add_module
macro(MAKE_SWIG_MODULE name language)

	if("${CMAKE_VERSION}" VERSION_GREATER 3.8)
		swig_add_library(${name}
	                   LANGUAGE ${language}
	                   TYPE MODULE
	                   SOURCES ${ARGN})
	else()
		swig_add_module(${name} ${language} ${ARGN})
	endif()

endmacro()


#! make_python_package_dir : create python package directory
#
# This function creates a python package directory and adds an __init__.py
# file or copies an existing custom __init__.py file. The function takes
# two arguments.
#
# \arg:ModuleName the desired python package name
# \arg:FileDir the directory path relative to the cmake script calling the function
#
function(make_python_package_dir ModuleName FileDir SWIG_OUTDIR)
	set(destination ${SWIG_OUTDIR})
    file(MAKE_DIRECTORY ${SWIG_OUTDIR})
	if(NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/__init__.py")
		file(WRITE "__init__.py" "# This __init__.py file for the ${ModuleName} package is automatically generated by the build system
from .${ModuleName} import *")
		file(COPY "__init__.py" DESTINATION ${destination})
	else()
		configure_file(${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/__init__.py ${destination}/__init__.py COPYONLY)
	endif()
	if (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/__init__.py")
		file(REMOVE "__init__.py")
	endif()
endfunction(make_python_package_dir)


#! make_python_package : create python package
#
# This function creates a python package directory and adds an __init__.py
# file or copies an existing custom __init__.py file. A list of package
# supporting files may be passed as the thried parameter. The function takes
# three arguments.
#
# \arg:FileNameWoExt the desired python package name
# \arg:FileDir the directory path relative to the cmake script calling the function
# \arg:moduleFilePath path to the Basilisk module's resulting python package directory
#
function(make_python_package FileNameWoExt FileDir SWIG_OUTDIR)
    # Create the output directory, write/copy an __init__.py file that imports the module.
	make_python_package_dir(${FileNameWoExt} ${FileDir} ${SWIG_OUTDIR})

	# Collect generated support files from the source directory (except for __init__.py)
	file(GLOB supportingFiles
		"${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/*.xml"
		"${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/*.py")
	list(REMOVE_ITEM supportingFiles ${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/__init__.py)

	# Create symlinks in the python package directory to any Basilisk module supporting files.
	create_symlinks(${SWIG_OUTDIR} ${supportingFiles})
endfunction(make_python_package)


#! create_symlinks : create symlinks to support files in source rather than keeping them in dist
# The function takes one required argument and N optional arguments.
# \argn: a list of supporting file paths
#
function(create_symlinks destinationPath)
    # Do nothing if building in-source
    if (${CMAKE_CURRENT_BINARY_DIR} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR})
        return()
    endif()

    foreach (filePath ${ARGN})
        get_filename_component(fileName ${filePath} NAME)

        # Get OS dependent path to use in `execute_process`
        file(TO_NATIVE_PATH "${destinationPath}/${fileName}" link)
        file(TO_NATIVE_PATH "${filePath}" target)

        # Delete the files from the dist directory, and instead just link them to the files in source
        file(REMOVE ${destinationPath}/${fileName})

        if (UNIX)
            set(command ln -s ${target} ${link})
        elseif(IS_DIRECTORY ${target})
            message("Creating Directory Symbolic Link")
            set(command cmd.exe /c mklink /D ${link} ${target})
        else()
            #message(target)
            set(command cmd.exe /c mklink ${link} ${target})
        endif()

        execute_process(COMMAND ${command}
                        RESULT_VARIABLE result
                        ERROR_VARIABLE output)

        # If the symlink is unsuccessful, then copy the file directly into dist
        if (NOT ${result} EQUAL 0)
            file( COPY ${target} DESTINATION ${destinationPath})
            message("Could not create symbolic link for: ${target} --> ${output}.  Copied instead")
        endif()

    endforeach(filePath)
endfunction(create_symlinks)




function(findAndCreateSwigModules SubModule)

	find_package(SWIG REQUIRED)
	include(${SWIG_USE_FILE}) # Include the UseSwig.cmake file

	#Include Python
  	if(USE_PYTHON3)
		find_package(PythonLibs 3 REQUIRED)
	else()
		find_package(PythonLibs 2 REQUIRED)
  	endif()
	include_directories(${PYTHON_INCLUDE_PATH})

	file(GLOB sub_directories RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/*)

    # Name the project "Simulation"
	string(FIND ${CMAKE_CURRENT_SOURCE_DIR} "/" DIR_NAME_START REVERSE)
	math(EXPR DIR_NAME_START "${DIR_NAME_START} + 1")
	string(SUBSTRING ${CMAKE_CURRENT_SOURCE_DIR} ${DIR_NAME_START} -1 DIR_NAME_STRING)
	project("${DIR_NAME_STRING}")

    # Get all swig source files (.i)
	file(GLOB_RECURSE swig_modules RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "*.i")

	# Get all of the libraries that will get linked to the swig modules
	get_property(LIBRARY_BUILD_LIST GLOBAL PROPERTY BUILT_LIB_LIST)
	get_property(ALG_LIST GLOBAL PROPERTY ALG_LIB_LIST)
	get_property(INTER_FILES GLOBAL PROPERTY SYS_INTER_FILES)

    # Make Simulation within the build directory and create the original __init__.py file
	file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/Basilisk/${SubModule}")
	file(WRITE "${CMAKE_BINARY_DIR}/Basilisk/${SubModule}__init__.py" "#empty init file")

	foreach(module ${swig_modules})
	    # Skip any modules that require custom CMakeLists.txt
	    if((NOT USE_PROTOBUFFERS OR NOT USE_ZMQ) AND (module IN_LIST requires_protobuff_modules OR module IN_LIST requires_zmq_modules))
               continue()
 	    endif()
 	    if((NOT USE_OPENCV) AND (module IN_LIST requires_opencv_modules))
 	           continue()
 	    endif()
 	    if((module IN_LIST requires_vulkan_modules))
 	           continue()
 	    endif()

	    get_filename_component(FileNameWoExt ${module} NAME_WE) # .i File Name without Extension
        get_filename_component(FileDir ${module} DIRECTORY) # FileDir

        # This defines where to write the language specific files (.py in our case)
	    set(CMAKE_SWIG_OUTDIR "${CMAKE_BINARY_DIR}/Basilisk/${SubModule}${FileNameWoExt}")

        # Grab all of the C/C++ source and header files
	    file(GLOB impl_files
		    "${FileDir}/*.cpp"
		    "${FileDir}/*.c"
		    "${FileDir}/*.h"
		    "${FileDir}/*.rst"
		)

		# Grab all of the BSK Framework files
	    file(GLOB gen_files
	        "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.cpp"
	        "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.h"
	        "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.c")

	    # Grab all of the BSK Framework SWIG source files
	    file(GLOB swig_dep_files "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.i")


        # Seperate the file directory into its parent and child directories
	    string(REPLACE "/" ";" DirList ${FileDir})

        # Search for additional _GeneralModuleFiles (.cpp/.c/.i) within subdirectories (i.e. dynamics/_GeneralModuleFiles)
        # and add them to the list of dependant files
        # TODO: These should become their own libraries so they aren't constantly getting reswigged/rebuilt
	    set(currentDir "")
	    set(endDir "")
	    foreach(localDir ${DirList})
	        set(currentDir "${currentDir}${localDir}/")
	        file(GLOB gen_files_loc
	            "${currentDir}_GeneralModuleFiles/*.cpp"
	            "${currentDir}_GeneralModuleFiles/*.h"
	            "${currentDir}_GeneralModuleFiles/*.c")
	        file(GLOB swig_dep_loc "${currentDir}_GeneralModuleFiles/*.i")
	        set(gen_files "${gen_files};${gen_files_loc}")
	        set(swig_dep_files "${swig_dep_files};${swig_dep_loc}")
	    set(endDir ${localDir})
	    endforeach()

	    # Uncertain why this would happen -- potentially legacy code
	    # TODO: Look into if this is necessary
	    if("${endDir}" STREQUAL "_GeneralModuleFiles")
	        continue()
	    endif()

		# Create the __init__.py files, and symlink any preexisting support files to the (to-be-populated) SWIG output directory
		make_python_package(${FileNameWoExt} ${FileDir} ${CMAKE_SWIG_OUTDIR})

        # Set the include flags
	    include_directories(${CMAKE_CURRENT_SOURCE_DIR}/${FileDir})

	    # Make sure the SWIG source file is in C++ mode
	    set_source_files_properties(${module} PROPERTIES CPLUSPLUS ON)

	    # Grants the module's .i file access to the other SWIG .i files needed for successful compilation
		set_property(SOURCE ${module} PROPERTY SWIG_FLAGS "-I${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles" "-I${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/")

		# Gives the generated _wrap.cxx file access to simulation directory
		# TODO: Determine why this is needed
		set_source_files_properties( ${swig_generated_file_fullname} PROPERTIES COMPILE_FLAGS "-I${CMAKE_SOURCE_DIR}/simulation")

	    # Specifies the C/C++ source files, the SWIG Source Files, and GeneralModule Source files
	    set(SWIG_MODULE_${FileNameWoExt}_EXTRA_DEPS ${impl_files} ${gen_files} ${swig_dep_files})

	    # Custom swig function (to allow support for CMake versions < 3 or > 3) that generates a library target.
	    MAKE_SWIG_MODULE(${FileNameWoExt} python ${module} ${impl_files} ${gen_files})

        # The built library target then gets linked with python, conan, and any odditional libraries
	    target_link_libraries(${FileNameWoExt} ${PYTHON_LIBRARIES})
	    target_link_libraries(${FileNameWoExt} ${CONAN_LIBS})

        if (USE_PROTOBUFFERS)
	       target_link_libraries(${FileNameWoExt} protocode) # TODO: This should be added to the BUILT_LIB_LIST rather than have its own conditional here.

        endif()
	    foreach(LibFile ${LIBRARY_BUILD_LIST})
	         target_link_libraries(${FileNameWoExt} ${LibFile})
	    endforeach()
	    foreach(LibFile ${library_dependencies})
	         target_link_libraries(${FileNameWoExt} ${LibFile}) # TODO: Same as above, spice should be added to BUILT_LIB_LIST rather than be in its own list object
	    endforeach()

        # Set some final properties for the target build
	    set_target_properties(${FileNameWoExt} PROPERTIES FOLDER "${DIR_NAME_STRING}/${FileDir}")
	    set_target_properties(${FileNameWoExt} PROPERTIES LIBRARY_OUTPUT_DIRECTORY "${CMAKE_SWIG_OUTDIR}")
	    set_target_properties(${FileNameWoExt} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_DEBUG "${CMAKE_SWIG_OUTDIR}")
		set_target_properties(${FileNameWoExt} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_RELEASE "${CMAKE_SWIG_OUTDIR}")
	    set_target_properties(${FileNameWoExt} PROPERTIES COMPILE_FLAGS "-I${CMAKE_CURRENT_SOURCE_DIR}")

	    #MESSAGE(STATUS "FILEDIR ${CMAKE_SWIG_OUTDIR}")


	endforeach()
endfunction(findAndCreateSwigModules)



function(sub_dir_list result curdir)
  # Searches through all directories in source, and keeps those called GeneralModuleFiles
  FILE(GLOB_RECURSE children LIST_DIRECTORIES true RELATIVE ${curdir} ${curdir}/*/)
  SET(dirlist "")
  FOREACH(child ${children})
    IF(IS_DIRECTORY ${curdir}/${child})
        string(FIND ${curdir}/${child} "_GeneralModuleFiles" FOUND)
        string(FIND ${curdir}/${child} "__pycache__" FOUND_PY)
        string(FIND ${curdir}/${child} "_UnitTest" FOUND_UNIT)
        IF(${FOUND} GREATER -1 AND ${FOUND_PY} EQUAL -1 AND ${FOUND_UNIT} EQUAL -1)
            LIST(APPEND dirlist ${child})
        ENDIF()
    ENDIF()
  ENDFOREACH()
  SET(${result} ${dirlist} PARENT_SCOPE)
endfunction(sub_dir_list)


function(generate_package_libraries INIT_DIRECTORY)
    # Find all _GeneralModuleFiles and put them into library targets so they aren't rewrapped, built with every module.

    # Find all _GeneralModuleFiles directories
    sub_dir_list(LIB_DIRS ${INIT_DIRECTORY})
    foreach(LIB_DIR ${LIB_DIRS})

        # Determine the name of the parent directory of _GeneralModuleFiles (i.e. dynamics, environment, etc)
        get_filename_component(PARENT_DIR ${LIB_DIR} DIRECTORY) # Relative to the source directory (e.g. simulation/power)
        string(FIND ${PARENT_DIR} "/" DIR_NAME_IDX REVERSE)
        math(EXPR DIR_NAME_IDX "${DIR_NAME_IDX} + 1")# "simulation/"
        string(SUBSTRING ${PARENT_DIR} ${DIR_NAME_IDX} -1 PARENT_DIR_NAME) # Should be (e.g. power)

        # Set the library name (ex. dynamicsLib, environmentLib, etc)
        set(LIB_NAME "${PARENT_DIR_NAME}Lib")

        # Grab the library source files
        file(GLOB C_FILES
                "${LIB_DIR}/*.cpp" # SH Base Class
                "${LIB_DIR}/*.c" # SH Base Class
                "${LIB_DIR}/*.h"
            )

        # Grab the framework source files
        file(GLOB BSK_FWK_FILES
            "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.cpp" #Might not be needed
            "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.h"
            "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.c"
            )

        # Add Target
        add_library(${LIB_NAME} SHARED ${C_FILES} ${BSK_FWK_FILES})

        # Link all necessary libraries
        target_link_libraries(${LIB_NAME} SimUtilities)
        target_link_libraries(${LIB_NAME} SimMessaging)
        target_link_libraries(${LIB_NAME} AlgorithmMessaging)
        target_link_libraries(${LIB_NAME} ${PYTHON_LIBRARIES})
	    target_link_libraries(${LIB_NAME} ${CONAN_LIBS})

        # define build location, IDE generation specifications
        set_target_properties(${LIB_NAME} PROPERTIES FOLDER ${PARENT_DIR})
        set_target_properties(${LIB_NAME} PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${PARENT_DIR})
        set_target_properties(${LIB_NAME} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_DEBUG ${PARENT_DIR})
        set_target_properties(${LIB_NAME} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_RELEASE ${PARENT_DIR})
    endforeach()
endfunction(generate_package_libraries)

function(find_package_targets PKG_DIR ALL_TARGET_LIST)
	file(GLOB_RECURSE SWIG_TARGETS RELATIVE ${CMAKE_SOURCE_DIR} "${PKG_DIR}/*.i")
	set(${ALL_TARGET_LIST} ${SWIG_TARGETS} PARENT_SCOPE)
endfunction(find_package_targets)

macro(is_cpp_module C_FILES CPP_FILE_EXISTS)
    # If there are no files, use c++ mode.
    if(NOT C_FILES)
        set(${CPP_FILE_EXISTS} 1)
        break()
    endif()

    # If there are files and there is a .cpp file, use c++ mode
    foreach(C_FILE ${C_FILES})
        get_filename_component(FILE_EXT ${C_FILE} EXT)
        string(COMPARE EQUAL ${FILE_EXT} ".cpp" OUTPUT_VAR)
        if(${OUTPUT_VAR})
            set(${CPP_FILE_EXISTS} ${OUTPUT_VAR})
            break()
        endif()
    endforeach()
endmacro(is_cpp_module)

function(generate_package_targets TARGET_LIST LIB_DEP_LIST IDE_DIR)

    find_package(SWIG REQUIRED)
    include(UseSwig REQUIRED)
    find_package(PythonLibs 3 REQUIRED)

    foreach(TARGET_FILE ${TARGET_LIST})
        get_filename_component(TARGET_NAME ${TARGET_FILE} NAME_WE)
        get_filename_component(PARENT_DIR ${TARGET_FILE} DIRECTORY)

        # Grab the target source files
        file(GLOB C_FILES
                "${PARENT_DIR}/*.c"
                "${PARENT_DIR}/*.cpp"
                "${PARENT_DIR}/*.h"
                "${PARENT_DIR}/*.rst"
            )

        set_property(SOURCE ${TARGET_FILE} PROPERTY SWIG_FLAGS "-I${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles" ) # This allows for swig_common_models.i to be imported

        is_cpp_module("${C_FILES}" CPP_FILE_EXISTS) # Need quotations around list, otherwise expands into other fcn parameters.
        if(${CPP_FILE_EXISTS})
            set_property(SOURCE ${TARGET_FILE} PROPERTY CPLUSPLUS ON)
        endif()

        # Add Target
        swig_add_library(${TARGET_NAME}
                           LANGUAGE "python"
                           TYPE MODULE
                           SOURCES ${TARGET_FILE} ${C_FILES})


        target_include_directories(${TARGET_NAME} PRIVATE ${PYTHON_INCLUDE_PATH}) #TODO: Check if this is the correct property identifier
        target_include_directories(${TARGET_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/${PARENT_DIR}) #This allows for the .h files to be imported to the PYTHON_wrap.c(xx) file

        # Link all necessary libraries
        foreach(LIB ${LIB_DEP_LIST})
            target_link_libraries(${TARGET_NAME} ${LIB})
        endforeach()

        # define build location, IDE generation specifications
        set_target_properties(${TARGET_NAME} PROPERTIES FOLDER ${PARENT_DIR})
        set_target_properties(${TARGET_NAME} PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${PARENT_DIR})
        set_target_properties(${TARGET_NAME} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_DEBUG ${PARENT_DIR})
        set_target_properties(${TARGET_NAME} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_RELEASE ${PARENT_DIR})
    endforeach()
endfunction(generate_package_targets)



function(temp)
    # Name the project "Simulation"
	string(FIND ${CMAKE_CURRENT_SOURCE_DIR} "/" DIR_NAME_START REVERSE)
	math(EXPR DIR_NAME_START "${DIR_NAME_START} + 1")
	string(SUBSTRING ${CMAKE_CURRENT_SOURCE_DIR} ${DIR_NAME_START} -1 DIR_NAME_STRING)
	project("${DIR_NAME_STRING}")

    # Get all swig source files (.i)
	file(GLOB_RECURSE swig_modules RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "*.i")

	# Get all of the libraries that will get linked to the swig modules
	get_property(LIBRARY_BUILD_LIST GLOBAL PROPERTY BUILT_LIB_LIST)
	get_property(ALG_LIST GLOBAL PROPERTY ALG_LIB_LIST)
	get_property(INTER_FILES GLOBAL PROPERTY SYS_INTER_FILES)

    # Make Simulation within the build directory and create the original __init__.py file
	file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/Basilisk/${SubModule}")
	file(WRITE "${CMAKE_BINARY_DIR}/Basilisk/${SubModule}__init__.py" "#empty init file")

	foreach(module ${swig_modules})
	    # Skip any modules that require custom CMakeLists.txt
	    if((NOT USE_PROTOBUFFERS OR NOT USE_ZMQ) AND (module IN_LIST requires_protobuff_modules OR module IN_LIST requires_zmq_modules))
               continue()
 	    endif()
 	    if((NOT USE_OPENCV) AND (module IN_LIST requires_opencv_modules))
 	           continue()
 	    endif()
 	    if((module IN_LIST requires_vulkan_modules))
 	           continue()
 	    endif()

	    get_filename_component(FileNameWoExt ${module} NAME_WE) # .i File Name without Extension
        get_filename_component(FileDir ${module} DIRECTORY) # FileDir

        # This defines where to write the language specific files (.py in our case)
	    set(CMAKE_SWIG_OUTDIR "${CMAKE_BINARY_DIR}/Basilisk/${SubModule}${FileNameWoExt}")

        # Grab all of the C/C++ source and header files
	    file(GLOB impl_files
		    "${FileDir}/*.cpp"
		    "${FileDir}/*.c"
		    "${FileDir}/*.h"
		    "${FileDir}/*.rst"
		)

		# Grab all of the BSK Framework files
	    file(GLOB gen_files
	        "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.cpp"
	        "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.h"
	        "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.c")

	    # Grab all of the BSK Framework SWIG source files
	    file(GLOB swig_dep_files "${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles/*.i")


        # Seperate the file directory into its parent and child directories
	    string(REPLACE "/" ";" DirList ${FileDir})

        # Search for additional _GeneralModuleFiles (.cpp/.c/.i) within subdirectories (i.e. dynamics/_GeneralModuleFiles)
        # and add them to the list of dependant files
        # TODO: These should become their own libraries so they aren't constantly getting reswigged/rebuilt
	    set(currentDir "")
	    set(endDir "")
	    foreach(localDir ${DirList})
	        set(currentDir "${currentDir}${localDir}/")
	        file(GLOB gen_files_loc
	            "${currentDir}_GeneralModuleFiles/*.cpp"
	            "${currentDir}_GeneralModuleFiles/*.h"
	            "${currentDir}_GeneralModuleFiles/*.c")
	        file(GLOB swig_dep_loc "${currentDir}_GeneralModuleFiles/*.i")
	        set(gen_files "${gen_files};${gen_files_loc}")
	        set(swig_dep_files "${swig_dep_files};${swig_dep_loc}")
	    set(endDir ${localDir})
	    endforeach()

	    # Uncertain why this would happen -- potentially legacy code
	    # TODO: Look into if this is necessary
	    if("${endDir}" STREQUAL "_GeneralModuleFiles")
	        continue()
	    endif()

		# Create the __init__.py files, and symlink any preexisting support files to the (to-be-populated) SWIG output directory
		make_python_package(${FileNameWoExt} ${FileDir} ${CMAKE_SWIG_OUTDIR})

        # Set the include flags
	    include_directories(${CMAKE_CURRENT_SOURCE_DIR}/${FileDir})

	    # Make sure the SWIG source file is in C++ mode
	    set_source_files_properties(${module} PROPERTIES CPLUSPLUS ON)

	    # Grants the module's .i file access to the other SWIG .i files needed for successful compilation
		set_property(SOURCE ${module} PROPERTY SWIG_FLAGS "-I${CMAKE_SOURCE_DIR}/simulation/_GeneralModuleFiles" "-I${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/")

		# Gives the generated _wrap.cxx file access to simulation directory
		# TODO: Determine why this is needed
		set_source_files_properties( ${swig_generated_file_fullname} PROPERTIES COMPILE_FLAGS "-I${CMAKE_SOURCE_DIR}/simulation")

	    # Specifies the C/C++ source files, the SWIG Source Files, and GeneralModule Source files
	    set(SWIG_MODULE_${FileNameWoExt}_EXTRA_DEPS ${impl_files} ${gen_files} ${swig_dep_files})

	    # Custom swig function (to allow support for CMake versions < 3 or > 3) that generates a library target.
	    MAKE_SWIG_MODULE(${FileNameWoExt} python ${module} ${impl_files} ${gen_files})

        # The built library target then gets linked with python, conan, and any odditional libraries
	    target_link_libraries(${FileNameWoExt} ${PYTHON_LIBRARIES})
	    target_link_libraries(${FileNameWoExt} ${CONAN_LIBS})

        if (USE_PROTOBUFFERS)
	       target_link_libraries(${FileNameWoExt} protocode) # TODO: This should be added to the BUILT_LIB_LIST rather than have its own conditional here.
        endif()
	    foreach(LibFile ${LIBRARY_BUILD_LIST})
	         target_link_libraries(${FileNameWoExt} ${LibFile})
	    endforeach()
	    foreach(LibFile ${library_dependencies})
	         target_link_libraries(${FileNameWoExt} ${LibFile}) # TODO: Same as above, spice should be added to BUILT_LIB_LIST rather than be in its own list object
	    endforeach()

        # Set some final properties for the target build
	    set_target_properties(${FileNameWoExt} PROPERTIES FOLDER "${DIR_NAME_STRING}/${FileDir}")
	    set_target_properties(${FileNameWoExt} PROPERTIES LIBRARY_OUTPUT_DIRECTORY "${CMAKE_SWIG_OUTDIR}")
	    set_target_properties(${FileNameWoExt} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_DEBUG "${CMAKE_SWIG_OUTDIR}")
		set_target_properties(${FileNameWoExt} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_RELEASE "${CMAKE_SWIG_OUTDIR}")
	    set_target_properties(${FileNameWoExt} PROPERTIES COMPILE_FLAGS "-I${CMAKE_CURRENT_SOURCE_DIR}")

	    #MESSAGE(STATUS "FILEDIR ${CMAKE_SWIG_OUTDIR}")


	endforeach()
endfunction(temp)








# Start of main projection configuration
if(USE_PYTHON3)
	find_package(PythonInterp 3 REQUIRED)
	find_package(PythonLibs 3 REQUIRED)
else()
	find_package(PythonInterp 2.7 REQUIRED)
	find_package(PythonLibs 2.7 REQUIRED)
endif()

############################################################################################
OPTION(USE_COVERAGE "GCOV code coverage analysis"      OFF)
############################################################################################

# Add general compiler flags
set(CMAKE_MACOSX_RPATH 1)
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2")

############################################################################################
IF (USE_COVERAGE AND (CMAKE_COMPILER_IS_GNUC OR CMAKE_COMPILER_IS_GNUCXX))
    MESSAGE(STATUS "USE_COVERAGE : ${USE_COVERAGE}")
    SET(GCOV_CFLAGS  "-fprofile-arcs -ftest-coverage -O0 -fno-default-inline -fno-inline")
    SET(GCOV_LDFLAGS "-fprofile-arcs -ftest-coverage -O0 -fno-default-inline -fno-inline")

    SET(CMAKE_C_FLAGS  "${CMAKE_C_FLAGS} ${GCOV_CFLAGS}")
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${GCOV_CFLAGS}")
    SET(CMAKE_LD_FLAGS "${CMAKE_LD_FLAGS} ${GCOV_LDFLAGS}")

    MESSAGE(STATUS "CMAKE_C_FLAGS : ${CMAKE_C_FLAGS}")
    MESSAGE(STATUS "CMAKE_CXX_FLAGS : ${CMAKE_CXX_FLAGS}")
    MESSAGE(STATUS "CMAKE_LD_FLAGS : ${CMAKE_LD_FLAGS}")
ENDIF()
#############################################################################################

# Add platform specific compiler flags
if(MSVC)
    add_definitions(/MP)
    add_definitions(/D _CRT_SECURE_NO_WARNINGS)
    add_definitions(/D _WINSOCK_DEPRECATED_NO_WARNINGS)
    add_definitions(/D _WIN32_WINNT=0x0501) # Targets Windows xp
    add_definitions(/W3)
    add_definitions(/wd"4913")
    add_definitions(/wd"4251")
    # Make sure we are using Multi-Threaded run time library
    foreach(flag
        CMAKE_C_FLAGS
        CMAKE_C_FLAGS_DEBUG
        CMAKE_C_FLAGS_RELEASE
        CMAKE_CXX_FLAGS
        CMAKE_CXX_FLAGS_DEBUG
        CMAKE_CXX_FLAGS_RELEASE)
        string(REPLACE "/D_DEBUG" "" "${flag}" "${${flag}}")
        string(REPLACE "/MD" "/MT" "${flag}" "${${flag}}")
        string(REPLACE "/MDd" "/MT" "${flag}" "${${flag}}")
        string(REPLACE "/MTd" "/MT" "${flag}" "${${flag}}")
        set("${flag}" "${${flag}} /EHsc")
    endforeach()
elseif(APPLE)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -gdwarf-3")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -gdwarf-3 -std=c++11 -stdlib=libc++")
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -gdwarf-3")
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}  -Wall")
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}  -Wall")
else()
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -gdwarf-3")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -gdwarf-3 -std=c++11 -fPIC")
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -gdwarf-3")
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}  -Wall")
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}  -Wall")
endif()

if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-deprecated-register -std=c++11")
endif()

# Add include directories
include_directories(simulation)
include_directories(../libs)

if(CMAKE_SIZEOF_VOID_P EQUAL 8)
  set(_arch_suffix 64)
else()
  set(_arch_suffix 32)
endif()




# Manually create list of libraries depending on system
if(WIN32)
	set(library_dependencies
      	${CMAKE_SOURCE_DIR}/../libs/cspice/lib/cspice_win${_arch_suffix}.lib
	)

        # fix for opencv not finding conan gflags for opencv sfm lib on windows
        # when the finding is fixed, the following line should be removed
        # https://github.com/conan-community/community/issues/210 
        list(REMOVE_ITEM CONAN_LIBS opencv_sfm411d multiview)

elseif(APPLE)
	set(library_dependencies ${CMAKE_SOURCE_DIR}/../libs/cspice/lib/cspice_osx.a)

	SET(CMAKE_SKIP_BUILD_RPATH  FALSE)	# use, i.e. don't skip the full RPATH for the build tree
	SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE) # when building, don't use the install RPATH already (but later on when installing)
	SET(CMAKE_INSTALL_RPATH "${CMAKE_BINARY_DIR}/Basilisk")# the RPATH to be used when installing

	# don't add the automatically determined parts of the RPATH
	# which point to directories outside the build tree to the install RPATH
	SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
else()
	set(library_dependencies ${CMAKE_SOURCE_DIR}/../libs/cspice/lib/cspice.a)
	set(CMAKE_SKIP_BUILD_RPATH  FALSE)
	set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)
	set(CMAKE_INSTALL_RPATH "\$ORIGIN/../../")
endif()

set_property(GLOBAL PROPERTY BUILT_LIB_LIST "SimUtilities;SimMessaging")
set_property(GLOBAL PROPERTY ALG_LIB_LIST "AlgorithmMessaging")
set_property(GLOBAL PROPERTY USE_FOLDERS ON)

# make the built package with an empty init file
file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/Basilisk")
file(WRITE "${CMAKE_BINARY_DIR}/Basilisk/__init__.py" "#empty init file written by the build")

#symlink into the package the current python module code
file(GLOB pythonModules
	"${CMAKE_SOURCE_DIR}/utilities/*.py"
	"${CMAKE_SOURCE_DIR}/utilities/**")
create_symlinks("${CMAKE_BINARY_DIR}/Basilisk/utilities" ${pythonModules})

#symlink into the package the test code
file(GLOB simTests "${CMAKE_SOURCE_DIR}/tests/*")
file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/Basilisk/tests")
file(WRITE "${CMAKE_BINARY_DIR}/Basilisk/tests/__init__.py" "#empty init file written by the build")
create_symlinks("${CMAKE_BINARY_DIR}/Basilisk/tests" ${simTests})

#symlink into package the supportData files to keep
file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/Basilisk/supportData")
file(GLOB dataFiles "${CMAKE_SOURCE_DIR}/../supportData/*")
create_symlinks("${CMAKE_BINARY_DIR}/Basilisk/supportData" ${dataFiles})

set(ARG setup.py develop --user)
execute_process(COMMAND ${PYTHON_EXECUTABLE} ${ARG}
								WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/../
								RESULT_VARIABLE rv
								OUTPUT_VARIABLE out)
message(STATUS "Adding Basilisk module to python with: ${PROGRAM} ${ARG} in ${CMAKE_SOURCE_DIR}/..
This resulted in the output:
${out}")

#if(USE_PROTOBUFFERS)
#  add_subdirectory("utilities/vizProtobuffer")
#endif()
#add_subdirectory("simulation")
#add_subdirectory("fswAlgorithms")
#add_subdirectory("topLevelModules")

add_subdirectory("simulation/utilities")
add_subdirectory("utilities")
add_subdirectory("simulation/architecture/messaging")
add_subdirectory("fswAlgorithms/messaging")


# TODO: Currently the libraries generated works well except for the simulationLib which really is the architectureLib -- I'd like for these files to be moved.
# TODO: I'd call this generate_libraries(), because it really does find all of them.
generate_package_libraries("${CMAKE_SOURCE_DIR}") # This finds GeneralModuleFiles and generates a library of the parentDirectory name

set(ARCHITECTURE_LIBS "simulationLib;SimUtilities;SimMessaging")


# The rationale for this is to explicitly specify packages that the user wants built. 
# TODO: We might automate this, and leave the custom libraries to CMakeLists found within the automated search. 
find_package_targets("${CMAKE_SOURCE_DIR}/simulation/dynamics" DYN_TARGETS) # Finds relative path of all .i files within the directory
generate_package_targets("${DYN_TARGETS}" "dynamicsLib;${ARCHITECTURE_LIBS}" "simulation") # The quotations around DYN_TARGETS informs function that it is a list

# TODO: Don't link cspice to all of the environment targets -- instead write a custom CMakeLists.txt file for spice_interface that includes it.
find_package_targets("${CMAKE_SOURCE_DIR}/simulation/environment" ENV_TARGETS) # Finds relative path of all .i files within the directory
generate_package_targets("${ENV_TARGETS}" "environmentLib;${ARCHITECTURE_LIBS};${library_dependencies}" "simulation") # Library Dependencies include cspice

find_package_targets("${CMAKE_SOURCE_DIR}/simulation/navigation" NAV_TARGETS)
generate_package_targets("${NAV_TARGETS}" "${ARCHITECTURE_LIBS};" "simulation")

find_package_targets("${CMAKE_SOURCE_DIR}/simulation/onboardDataHandling" DATA_TARGETS)
generate_package_targets("${DATA_TARGETS}" "onboardDataHandlingLib;${ARCHITECTURE_LIBS};" "simulation")



# This is the flight software section
find_package_targets("${CMAKE_SOURCE_DIR}/fswAlgorithms/attDetermination" ATT_DET_TARGETS)
generate_package_targets("${ATT_DET_TARGETS}" "attDeterminationLib;${ARCHITECTURE_LIBS};" "fswAlgorithms")


#run python script to modify swig gen code
add_custom_target(OverwriteSwig ALL)
set(ARG utilities/overwriteSwig.py ${CMAKE_BINARY_DIR} ${SWIG_VERSION})
add_custom_command(
    TARGET OverwriteSwig
    COMMAND ${PYTHON_EXECUTABLE} ${ARG}
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/../src/)
if(TARGET _thrusterDynamicEffector)
    add_dependencies(OverwriteSwig _thrusterDynamicEffector _vscmgStateEffector _reactionWheelStateEffector)
elseif(TARGET thrusterDynamicEffector)
    add_dependencies(OverwriteSwig thrusterDynamicEffector vscmgStateEffector reactionWheelStateEffector)
endif()
