#define SWIGPYTHON_BUILTIN

%module messaging2
%pythoncode %{
    from Basilisk.simulation.swig_common_model import *
%}
%include "swig_conly_data.i"
%include "std_vector.i"
%include "std_string.i"
%include "../../utilities/macroDefinitions.h"
%pythoncode %{
    import numpy as np
%};
%{
#include "../../_GeneralModuleFiles/sys_model.h"
#include "messaging2.h"
#include <vector>
%}
%template(TimeVector) std::vector<uint64_t>;
%include "std_vector.i"
%include "../../_GeneralModuleFiles/sys_model.h"
%include "messaging2.h"
%rename(__subscribe_to) subscribeTo;  // we want the users to have a unified "subscribeTo" interface
%rename(__subscribe_to_C) subscribeToC;  // we want the users to have a unified "subscribeTo" interface
%rename(__time_vector) times;  // It's not really useful to give the user back a time vector
%rename(__record_vector) record;
%define INSTANTIATE_TEMPLATES(messageType)
%{
#include "cMsgDefinition/messageType.h"
%}
%include "cMsgDefinition/messageType.h"

%pythoncode %{
    def writeCMsgCppInterface(payload, **kwargs):
        """Python interface to write a C msg with a C++ interface.

        Keyword arguments:
            time - [ns] time the message was written.  Defaults to 0 if not provided.
        """
        # check if msg write time is specified, if not, default to 0
        if 'time' in kwargs:
            time = kwargs['time']
            error = False
            if not isinstance(time, int):
                error = True
            if time < 0:
                error = True
            if error:
                print("writeCMsgCppInterface time argument must be a positive integer in nano-seconds.")
                exit(1)
        else:
            time = 0

        # find the msg structure name
        typeString = str(type(payload))
        msgStructName = (typeString.split('messaging2.')[1])[:-2]

        # create the C++ interface to the C message structure
        msg = eval(msgStructName + 'Class()')
        msgWriter = msg.addAuthor()
        msgWriter(payload, time)

        return msg
%}

%template(messageType ## Reader) ReadFunctor<messageType>;
%extend ReadFunctor<messageType> {
        %pythoncode %{
            def subscribeTo(self, source):
                from Basilisk.simulation.cMsgCInterfacePy import messageType ## _C
                if type(source) == messageType ## Class:
                    self.__subscribe_to(source)
                elif type(source) == messageType ## _C:
                    self.__subscribe_to_C(source)
                else:
                    raise Exception('tried to subscribe ReadFunctor<messageType> to another message type')
        %}
};

%template(messageType ## Writer) WriteFunctor<messageType>;

%template(messageType ## Class) SimMessage<messageType>;

%template(messageType ## Logger) Log<messageType>;
%extend Log<messageType> {
    %pythoncode %{
        def times(self):
            return np.array(self.__time_vector())

        # This __getattr__ is written in message.i.
        # It lets us return message struct attribute record as lists for plotting, etc.
        def __getattr__(self, name):
            data = self.__record_vector()
            data_log = []
            for rec in data.iterator():
                data_log.append(rec.__getattribute__(name))
            return np.array(data_log)

        def record(self):
            return self.__record_vector
    %}
};

typedef struct messageType;

%template(messageType ## Vector) std::vector<messageType>;
%extend std::vector<messageType>{
    %pythoncode %{
        # This __getattr__ is written in message.i.
        # It lets us return message struct attribute record as lists for plotting, etc.
        def __getattr__(self, name):
            data_log = []
            for rec in self.iterator():
                data_log.append(rec.__getattribute__(name))
            return np.array(data_log)
    %}
};
%enddef


