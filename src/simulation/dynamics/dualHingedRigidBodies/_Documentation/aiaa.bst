%%%% This is file `aiaa.bst',%% generated with the docstrip utility.%%%% The original source files were:%%%% aiaa.dtx  (with options: `bibstyle')%% %% The "aiaa" distribution by bil kleb <w.l.kleb@larc.nasa.gov>.%% Please see the file `aiaa.ins' for information on how you may%% (re-)distribute the `aiaa' bundle of files.%% %% Description: a bundle of LaTeX and BibTeX files to produce%%              AIAA papers and simulated journal articles/notes%% Keywords: LaTeX, class, AIAA, BibTeX, bibliographic-style, 9pt-option%% Author: Bil Kleb <w.l.kleb@larc.nasa.gov>%% Maintainer: same%% Version: 2.1 <04 aug 1998>%%%% Please see the information in file `aiaa.ins' on how you%% may use and (re-)distribute this file.  Run LaTeX on the file%% `aiaa.ins' to get the main aiaa class and other auxilary packages.%% Also run LaTeX on `aiaa.dtx' (this file) to obtain a users manual%% and code documentation.%%%% NOTE: This file may NOT be distributed if not accompanied by 'aiaa.ins'%%       and `aiaalgo.eps'.%% \CharacterTable%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z%%   Digits        \0\1\2\3\4\5\6\7\8\9%%   Exclamation   \!     Double quote  \"     Hash (number) \#%%   Dollar        \$     Percent       \%     Ampersand     \&%%   Acute accent  \'     Left paren    \(     Right paren   \)%%   Asterisk      \*     Plus          \+     Comma         \,%%   Minus         \-     Point         \.     Solidus       \/%%   Colon         \:     Semicolon     \;     Less than     \<%%   Equals        \=     Greater than  \>     Question mark \?%%   Commercial at \@     Left bracket  \[     Backslash     \\%%   Right bracket \]     Circumflex    \^     Underscore    \_%%   Grave accent  \`     Left brace    \{     Vertical bar  \|%%   Right brace   \}     Tilde         \~}ENTRY  { address    author    booktitle    chapter    edition    editor    howpublished    institution    journal    key    month    note    number    organization    pages    publisher    school    series    title    type    volume    year
    
    doi  }  {}  { label }INTEGERS { output.state before.all mid.sentence after.sentence after.block }FUNCTION {init.state.consts}{ #0 'before.all :=  #1 'mid.sentence :=  #2 'after.sentence :=  #3 'after.block :=}STRINGS { s t }FUNCTION {output.nonnull}{ 's :=  output.state mid.sentence =    { ", " * write$ }    { output.state after.block =        { add.period$ write$          newline$          "\newblock " write$        }        { output.state before.all =            'write$            { add.period$ " " * write$ }          if$        }      if$      mid.sentence 'output.state :=    }  if$  s}FUNCTION {output}{ duplicate$ empty$    'pop$    'output.nonnull  if$}FUNCTION {output.check}{ 't :=  duplicate$ empty$    { pop$ "empty " t * " in " * cite$ * warning$ }    'output.nonnull  if$}FUNCTION {fin.entry}{ add.period$  write$  newline$}FUNCTION {new.block}{ output.state before.all =    'skip$    { after.block 'output.state := }  if$}FUNCTION {new.sentence}{ output.state after.block =    'skip$    { output.state before.all =        'skip$        { after.sentence 'output.state := }      if$    }  if$}FUNCTION {add.blank}{  " " * before.all 'output.state :=}FUNCTION {date.block}{  skip$}FUNCTION {not}{   { #0 }    { #1 }  if$}FUNCTION {and}{   'skip$    { pop$ #0 }  if$}FUNCTION {or}{   { pop$ #1 }    'skip$  if$}FUNCTION {non.stop}{ duplicate$   "}" * add.period$   #-1 #1 substring$ "." =}FUNCTION {new.block.checka}{ empty$    'skip$    'new.block  if$}FUNCTION {new.block.checkb}{ empty$  swap$ empty$  and    'skip$    'new.block  if$}FUNCTION {new.sentence.checka}{ empty$    'skip$    'new.sentence  if$}FUNCTION {new.sentence.checkb}{ empty$  swap$ empty$  and    'skip$    'new.sentence  if$}FUNCTION {field.or.null}{ duplicate$ empty$    { pop$ "" }    'skip$  if$}FUNCTION {emphasize}{ duplicate$ empty$    { pop$ "" }    { "{\em " swap$ * "\/}" * }  if$}FUNCTION {capitalize}{ "u" change.case$ "t" change.case$ }FUNCTION {space.word}{ " " swap$ * " " * } % Here are the language-specific definitions for explicit words. % Each function has a name bbl.xxx where xxx is the English word. % The language selected here is ENGLISHFUNCTION {bbl.and}{ "and"}FUNCTION {bbl.editors}{ "editors" }FUNCTION {bbl.editor}{ "editor" }FUNCTION {bbl.edby}{ "edited by" }FUNCTION {bbl.edition}{ "ed." }FUNCTION {bbl.volume}{ "Vol." }FUNCTION {bbl.of}{ "of" }FUNCTION {bbl.number}{ "No." }FUNCTION {bbl.nr}{ "No." }FUNCTION {bbl.in}{ "in" }FUNCTION {bbl.pages}{ "pp." }FUNCTION {bbl.page}{ "p." }FUNCTION {bbl.chapter}{ "chap." }FUNCTION {bbl.techrep}{ "Tech. Report" }FUNCTION {bbl.mthesis}{ "Master's thesis" }FUNCTION {bbl.phdthesis}{ "Ph.D. thesis" }FUNCTION {bbl.first}{ "1st" }FUNCTION {bbl.second}{ "2nd" }FUNCTION {bbl.third}{ "3rd" }FUNCTION {bbl.fourth}{ "4th" }FUNCTION {bbl.fifth}{ "5th" }FUNCTION {bbl.st}{ "st" }FUNCTION {bbl.nd}{ "nd" }FUNCTION {bbl.rd}{ "rd" }FUNCTION {bbl.th}{ "th" }MACRO {jan} {"Jan."}MACRO {feb} {"Feb."}MACRO {mar} {"Mar."}MACRO {apr} {"Apr."}MACRO {may} {"May"}MACRO {jun} {"Jun."}MACRO {jul} {"Jul."}MACRO {aug} {"Aug."}MACRO {sep} {"Sep."}MACRO {oct} {"Oct."}MACRO {nov} {"Nov."}MACRO {dec} {"Dec."}MACRO {jan-feb} {"Jan.-Feb."}MACRO {mar-apr} {"Mar.-Apr."}MACRO {may-jun} {"May-Jun."}MACRO {jul-aug} {"Jul.-Aug."}MACRO {sep-oct} {"Sep.-Oct."}MACRO {nov-dec} {"Nov.-Dec."}FUNCTION {eng.ord}{ duplicate$ "1" swap$ *  #-2 #1 substring$ "1" =     { bbl.th * }     { duplicate$ #-1 #1 substring$       duplicate$ "1" =         { pop$ bbl.st * }         { duplicate$ "2" =             { pop$ bbl.nd * }             { "3" =                 { bbl.rd * }                 { bbl.th * }               if$             }           if$          }       if$     }   if$}MACRO {jsr} {"Journal of Spacecraft and Rockets"}MACRO {aa} {"Aerospace America"}MACRO {sn} {"Space News"}MACRO {awst} {"Aviation Week \& Space Technology"}MACRO {jcp} {"Journal of Computational Physics"}MACRO {ijcfd} {"International Journal of Computational Fluid Dynamics"}MACRO {ijnme} {"International Journal for Numerical Methods in Engineering"}MACRO {acmcs} {"ACM Computing Surveys"}MACRO {acta} {"Acta Informatica"}MACRO {cacm} {"Communications of the ACM"}MACRO {ibmjrd} {"IBM Journal of Research and Development"}MACRO {ibmsj} {"IBM Systems Journal"}MACRO {ieeese} {"IEEE Transactions on Software Engineering"}MACRO {ieeetc} {"IEEE Transactions on Computers"}MACRO {ieeetcad} {"IEEE Transactions on Computer-Aided Design of Integrated Circuits"}MACRO {ipl} {"Information Processing Letters"}MACRO {jacm} {"Journal of the ACM"}MACRO {jcss} {"Journal of Computer and System Sciences"}MACRO {scp} {"Science of Computer Programming"}MACRO {sicomp} {"SIAM Journal on Computing"}MACRO {tocs} {"ACM Transactions on Computer Systems"}MACRO {tods} {"ACM Transactions on Database Systems"}MACRO {tog} {"ACM Transactions on Graphics"}MACRO {toms} {"ACM Transactions on Mathematical Software"}MACRO {toois} {"ACM Transactions on Office Information Systems"}MACRO {toplas} {"ACM Transactions on Programming Languages and Systems"}MACRO {tcs} {"Theoretical Computer Science"}INTEGERS { nameptr namesleft numnames }FUNCTION {format.names}{ 's :=  #1 'nameptr :=  s num.names$ 'numnames :=  numnames 'namesleft :=    { namesleft #0 > }    { s nameptr      "{vv~}{ll}{, jj}{, f.}" format.name$ 't :=      nameptr #1 >        {          namesleft #1 >            { ", " * t * }            {              numnames #2 >                { "," * }                'skip$              if$              t "others" =                { " et~al." * }                { bbl.and space.word * t * }              if$            }          if$        }        't      if$      nameptr #1 + 'nameptr :=      namesleft #1 - 'namesleft :=    }  while$}FUNCTION {format.names.ed}{ 's :=  #1 'nameptr :=  s num.names$ 'numnames :=  numnames 'namesleft :=    { namesleft #0 > }    { s nameptr      "{f.~}{vv~}{ll}{, jj}"      format.name$ 't :=      nameptr #1 >        {          namesleft #1 >            { ", " * t * }            {              numnames #2 >                { "," * }                'skip$              if$              t "others" =                { " et~al." * }                { bbl.and space.word * t * }              if$            }          if$        }        't      if$      nameptr #1 + 'nameptr :=      namesleft #1 - 'namesleft :=    }  while$}FUNCTION {format.authors}{ author empty$    { "" }    {      author format.names    }  if$}

FUNCTION {format.doi}{ doi empty$    { "" *}    { ", doi:" * doi *}  if$}FUNCTION {format.editors}{ editor empty$    { "" }    {      editor format.names      editor num.names$ #1 >        { ", " * bbl.editors * }        { ", " * bbl.editor * }      if$    }  if$}FUNCTION {format.in.editors}{ editor empty$    { "" }    { editor format.names.ed    }  if$}FUNCTION {format.title}{ title empty$    { "" }    { title      "\enquote{" swap$ *      non.stop        { ",} " * }        { "} " * }      if$    }  if$}FUNCTION {end.quote.title}{ title empty$    'skip$    { before.all 'output.state := }  if$}FUNCTION {output.bibitem}{ newline$  "\bibitem{" write$  cite$ write$  "}" write$  newline$  ""  before.all 'output.state :=}FUNCTION {n.dashify}{ 't :=  ""    { t empty$ not }    { t #1 #1 substring$ "-" =        { t #1 #2 substring$ "--" = not            { "--" *              t #2 global.max$ substring$ 't :=            }            {   { t #1 #1 substring$ "-" = }                { "-" *                  t #2 global.max$ substring$ 't :=                }              while$            }          if$        }        { t #1 #1 substring$ *          t #2 global.max$ substring$ 't :=        }      if$    }  while$}FUNCTION {word.in}{ "" }FUNCTION {format.date}{ year empty$    { month empty$        { "" }        { "there's a month but no year in " cite$ * warning$          month        }      if$    }    { month empty$        'year        { month " " * year * }      if$    }  if$}FUNCTION {format.btitle}{ title emphasize}FUNCTION {tie.or.space.connect}{ duplicate$ text.length$ #3 <    { "~" }    { " " }  if$  swap$ * *}FUNCTION {either.or.check}{ empty$    'pop$    { "can't use both " swap$ * " fields in " * cite$ * warning$ }  if$}FUNCTION {format.bvolume}{ volume empty$    { "" }    { bbl.volume volume tie.or.space.connect      series empty$        'skip$        { bbl.of space.word * series emphasize * }      if$      "volume and number" number either.or.check    }  if$}FUNCTION {format.number.series}{ volume empty$    { number empty$        { series field.or.null }        { output.state mid.sentence =            { bbl.number }            { bbl.number capitalize }          if$          number tie.or.space.connect          series empty$            { "there's a number but no series in " cite$ * warning$ }            { bbl.in space.word * series * }          if$        }      if$    }    { "" }  if$}FUNCTION {is.num}{ chr.to.int$  duplicate$ "0" chr.to.int$ < not  swap$ "9" chr.to.int$ > not and}FUNCTION {extract.num}{ duplicate$ 't :=  "" 's :=  { t empty$ not }  { t #1 #1 substring$    t #2 global.max$ substring$ 't :=    duplicate$ is.num      { s swap$ * 's := }      { pop$ "" 't := }    if$  }  while$  s empty$    'skip$    { pop$ s }  if$}FUNCTION {convert.edition}{ edition extract.num "l" change.case$ 's :=  s "first" = s "1" = or    { bbl.first 't := }    { s "second" = s "2" = or        { bbl.second 't := }        { s "third" = s "3" = or            { bbl.third 't := }            { s "fourth" = s "4" = or                { bbl.fourth 't := }                { s "fifth" = s "5" = or                    { bbl.fifth 't := }                    { s #1 #1 substring$ is.num                        { s eng.ord 't := }                        { edition 't := }                      if$                    }                  if$                }              if$            }          if$        }      if$    }  if$  t}FUNCTION {format.edition}{ edition empty$    { "" }    { output.state mid.sentence =        { convert.edition "l" change.case$ " " * bbl.edition * }        { convert.edition "t" change.case$ " " * bbl.edition * }      if$    }  if$}INTEGERS { multiresult }FUNCTION {multi.page.check}{ 't :=  #0 'multiresult :=    { multiresult not      t empty$ not      and    }    { t #1 #1 substring$      duplicate$ "-" =      swap$ duplicate$ "," =      swap$ "+" =      or or        { #1 'multiresult := }        { t #2 global.max$ substring$ 't := }      if$    }  while$  multiresult}FUNCTION {format.pages}{ pages empty$    { "" }    { pages multi.page.check        { bbl.pages pages n.dashify tie.or.space.connect }        { bbl.page pages tie.or.space.connect }      if$    }  if$}FUNCTION {format.journal.pages}{  pages empty$    'skip$    { duplicate$ empty$        { pop$ format.pages }        { ", " * bbl.pages "~" * * pages n.dashify * }      if$    }  if$}FUNCTION {format.vol.num.pages}{ volume field.or.null  volume empty$    'skip$    { bbl.volume "~" * swap$ * }  if$  number empty$    'skip$    {      ", " bbl.nr * number tie.or.space.connect *      volume empty$        { "there's a number but no volume in " cite$ * warning$ }        'skip$      if$    }  if$}FUNCTION {format.chapter.pages}{ chapter empty$    { "" }    { type empty$        { bbl.chapter }        { type "l" change.case$ }      if$      chapter tie.or.space.connect    }  if$}FUNCTION {format.in.ed.booktitle}{ booktitle empty$    { "" }    { editor empty$        { word.in booktitle emphasize * }        { word.in booktitle emphasize *          ", " *          bbl.edby          *          " " *          format.in.editors *        }      if$    }  if$}FUNCTION {empty.misc.check}{ author empty$ title empty$ howpublished empty$  month empty$ year empty$ note empty$  and and and and and    { "all relevant fields are empty in " cite$ * warning$ }    'skip$  if$}FUNCTION {format.thesis.type}{ type empty$    'skip$    { pop$      type "t" change.case$    }  if$}FUNCTION {format.tr.number}{ type empty$    { bbl.techrep }    'type  if$  number empty$    { "t" change.case$ }    { number tie.or.space.connect }  if$}FUNCTION {format.article.crossref}{  key empty$    { journal empty$        { "need key or journal for " cite$ * " to crossref " * crossref *          warning$          ""        }        { word.in journal emphasize * }      if$    }    { word.in key * " " *}  if$  " \cite{" * crossref * "}" *}FUNCTION {format.crossref.editor}{ editor #1 "{vv~}{ll}" format.name$  editor num.names$ duplicate$  #2 >    { pop$ " et~al." * }    { #2 <        'skip$        { editor #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =            { " et~al." * }            { bbl.and space.word * editor #2 "{vv~}{ll}" format.name$ * }          if$        }      if$    }  if$}FUNCTION {format.book.crossref}{ volume empty$    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$      word.in    }    { bbl.volume volume tie.or.space.connect      bbl.of space.word *    }  if$  editor empty$  editor field.or.null author field.or.null =  or    { key empty$        { series empty$            { "need editor, key, or series for " cite$ * " to crossref " *              crossref * warning$              "" *            }            { series emphasize * }          if$        }        { key * }      if$    }    { format.crossref.editor * }  if$  " \cite{" * crossref * "}" *}FUNCTION {format.incoll.inproc.crossref}{  editor empty$  editor field.or.null author field.or.null =  or    { key empty$        { booktitle empty$            { "need editor, key, or booktitle for " cite$ * " to crossref " *              crossref * warning$              ""            }            { word.in booktitle emphasize * }          if$        }        { word.in key * " " *}      if$    }    { word.in format.crossref.editor * " " *}  if$  " \cite{" * crossref * "}" *}FUNCTION {format.publisher}{ publisher empty$    { "empty publisher in " cite$ * warning$ }    'skip$  if$  ""  address empty$ publisher empty$ and    'skip$    {      publisher empty$        { address empty$          'skip$          { address * }          if$        }        { publisher *          address empty$            'skip$            { ", " * address * }          if$        }      if$    }  if$  output}FUNCTION {article}{ output.bibitem  format.authors "author" output.check  format.title "title" output.check  end.quote.title  crossref missing$    { journal      emphasize      "journal" output.check      format.vol.num.pages output      format.date "year" output.check    }    { format.article.crossref output.nonnull      format.pages output    }  if$  format.journal.pages  note output
  format.doi 
  fin.entry}FUNCTION {book}{ output.bibitem  author empty$    { format.editors "author and editor" output.check    }    { format.authors output.nonnull      crossref missing$        { "author and editor" editor either.or.check }        'skip$      if$    }  if$  format.btitle "title" output.check  crossref missing$    { format.bvolume output      format.number.series output      format.publisher    }    {      format.book.crossref output.nonnull    }  if$  format.edition output  format.date "year" output.check  note output
  format.doi 
  fin.entry}FUNCTION {booklet}{ output.bibitem  format.authors output  format.title "title" output.check  end.quote.title  howpublished output  address output  format.date output  note output
  format.doi 
  fin.entry}FUNCTION {inbook}{ output.bibitem  author empty$    { format.editors "author and editor" output.check    }    { format.authors output.nonnull      crossref missing$        { "author and editor" editor either.or.check }        'skip$      if$    }  if$  format.btitle "title" output.check  crossref missing$    {      format.bvolume output      format.chapter.pages "chapter and pages" output.check      format.number.series output      format.publisher    }    {      format.chapter.pages "chapter and pages" output.check      format.book.crossref output.nonnull    }  if$  format.edition output  format.date "year" output.check  format.pages "pages" output.check  note output
  format.doi 
  fin.entry}FUNCTION {incollection}{ output.bibitem  format.authors "author" output.check  format.title "title" output.check  end.quote.title  crossref missing$    { format.in.ed.booktitle "booktitle" output.check      format.bvolume output      format.number.series output      format.chapter.pages output      format.publisher      format.edition output      format.date "year" output.check    }    { format.incoll.inproc.crossref output.nonnull      format.chapter.pages output    }  if$  format.pages "pages" output.check  note output
  format.doi 
  fin.entry}FUNCTION {inproceedings}{ output.bibitem  format.authors "author" output.check  format.title "title" output.check  end.quote.title  crossref missing$    { format.in.ed.booktitle "booktitle" output.check      format.bvolume output      format.number.series output      publisher empty$        { organization output          address output        }        { organization output          format.publisher        }      if$      format.date "year" output.check    }    { format.incoll.inproc.crossref output.nonnull      format.pages output    }  if$  format.pages "pages" output.check  note output
  format.doi 
  fin.entry}FUNCTION {conference} { inproceedings }FUNCTION {manual}{ output.bibitem  author empty$    { organization empty$        'skip$        { organization output.nonnull          address output        }      if$    }    { format.authors output.nonnull }  if$  format.btitle "title" output.check  author empty$    { organization empty$    {          address output        }        'skip$      if$    }    {      organization output      address output    }  if$  format.edition output  format.date output  note output
  format.doi 
  fin.entry}FUNCTION {mastersthesis}{ output.bibitem  format.authors "author" output.check  format.btitle "title" output.check  bbl.mthesis format.thesis.type output.nonnull  school "school" output.check  address output  format.date "year" output.check  note output
  format.doi 
  fin.entry}FUNCTION {misc}{ output.bibitem  format.authors output  format.title output  end.quote.title  howpublished output  format.date output  note output
  format.doi 
  fin.entry  empty.misc.check}FUNCTION {phdthesis}{ output.bibitem  format.authors "author" output.check  format.btitle "title" output.check  bbl.phdthesis format.thesis.type output.nonnull  school "school" output.check  address output  format.date "year" output.check  note output
  format.doi 
  fin.entry}FUNCTION {proceedings}{ output.bibitem  editor empty$    { organization output }    { format.editors output.nonnull }  if$  format.btitle "title" output.check  format.bvolume output  format.number.series output  address empty$    { editor empty$        { publisher new.sentence.checka }        { organization publisher new.sentence.checkb          organization output        }      if$      publisher output      format.date "year" output.check    }    { address output.nonnull      format.date "year" output.check      editor empty$        'skip$        { organization output }      if$      publisher output    }  if$  note output
  format.doi 
  fin.entry}FUNCTION {techreport}{ output.bibitem  format.authors "author" output.check  format.title "title" output.check  end.quote.title  format.tr.number output.nonnull  institution "institution" output.check  address output  format.date "year" output.check  note output
  format.doi 
  fin.entry}FUNCTION {unpublished}{ output.bibitem  format.authors "author" output.check  format.title "title" output.check  end.quote.title  note "note" output.check  fin.entry}FUNCTION {default.type} { misc }READSTRINGS { longest.label }INTEGERS { number.label longest.label.width }FUNCTION {initialize.longest.label}{ "" 'longest.label :=  #1 'number.label :=  #0 'longest.label.width :=}FUNCTION {longest.label.pass}{ number.label int.to.str$ 'label :=  number.label #1 + 'number.label :=  label width$ longest.label.width >    { label 'longest.label :=      label width$ 'longest.label.width :=    }    'skip$  if$}EXECUTE {initialize.longest.label}ITERATE {longest.label.pass}FUNCTION {begin.bib}{ preamble$ empty$    'skip$    { preamble$ write$ newline$ }  if$  "\begin{thebibliography}{"  longest.label  * "}" *  write$ newline$  "\newcommand{\enquote}[1]{``#1''}"  write$ newline$}EXECUTE {begin.bib}EXECUTE {init.state.consts}ITERATE {call.type$}FUNCTION {end.bib}{ newline$  "\end{thebibliography}" write$ newline$}EXECUTE {end.bib}%% %%%% End of file `aiaa.bst'.