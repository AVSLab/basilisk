\section{Model Description}
The Basilisk IMU module imu\_sensor.cpp is responsible for producing sensed body rates and acceleration from simulation truth values. It also provides a change in velocity and change in attitude value for the time between IMU calls. Each check within test\_imu\_sensor.py sets initial attitude MRP, body rates, and accumulated Delta V and validates output for a range of time.

There is a large variation throughout the industry as to what constitutes and IMU.  Some manufacturers offer IMUs which output only acceleration and angular rate while others include accumulated change in velocity in attitude. For Basilisk, the IMU is defined as a device which outputs all four values.

\subsection{Mathematical Model}

\subsubsection{Angular Rates}
The angular rate of the sensor is output as:
\begin{equation}
	^P\bm{\omega}_{S/N} = [PB] ^B\bm{\omega}_{B/N}
\end{equation}
Where $P$ is the sensor platform frame, $B$ is the vehicle body frame, and $N$ is the inertial frame. $[PB]$ is the direction cosine matrix from $B$ to $P$. This allows for an arbitrary angular offset between $B$ and $P$ but does not allow for that offset to be time-varying.

\subsubsection{Angular Displacement}
The IMU also outputs the angular displacement accumulated between IMU calls. In order to avoid complexities having to do with the relative timestep between the dynamics process and the IMU calls, this is not calculated in the same way as an IMU works physically. In this way, also, the dynamics do not have to be run at a fast enough rate for a physical IMU angular accumulation to be simulated. 
The modified Rodriguez parameter (MRP) is recorded for the last time (1) the IMU was called. It is then differenced with the current (2) MRP:
\begin{equation}
	\bm{\sigma}_{2/1} = \bm{\sigma}_{B/N,2} - \bm{\sigma}_{B/N,1}
\end{equation}
This is interpreted as the MRP from the body frame at time 1 to the body frame at time 2. $\bm{\sigma}_{2/1}$ is then converted to a principle rotation vector (PRV) in the current body frame and that vector is rotated into the sensor platform frame:
\begin{equation}
		^Bq_{i} = \frac{\sigma_{2/1,i}}{|\bm{\sigma}_{2/1}| 4 \mathrm{tan}^{-1}(|\bm{\sigma}_{2/1}|)}
\end{equation}
\begin{equation}
	^P\bm{q} = [PB] ^B\bm{q}
\end{equation}
Above, $q$ is the PRV and $i$ indicates the $i^{\mathrm{th}}$ component of $\bm{q}$ and $\bm{\sigma}$. $\bm{q}$ is then made of the elements $q_1$, $q_2$, and $q_3$. $q$ is the module output for angular displacement.

Additionally, this method has minor added complexity due to the fact that the spacecraftPlus module sometimes switches between the original MRP set and the shadow MRP set. It does, though, record the number of times that this switch has occurred. The IMU uses this data to calculate whether the MRP has been switched an even or odd number of times since the IMU was last called. If the number is even, no MRP conversion must be done. If it is odd, the MRP must be converted to the shadow set via:


\subsubsection{Linear Acceleration}
The sensor is assumed to have an arbitrary offset from the center of mass of the spacecraft. However, because of the completely coupled nature of the Basilisks dynamics framework, the center of mass does not need to be present explicitly in equations of motion for the sensor. It is implicit in the motion of the body frame. With that in mind, the equation for the acceleration of the sensor is derived below:

\begin{equation}
\bm{r}_{S/N} = \bm{r}_{B/N} + \bm{r}_{S/B}
\end{equation}

Using the transport theorem for $\dot{\bm{r}}_{S/B}$:
\begin{equation}
	\dot{\bm{r}}_{S/N} = \dot{\bm{r}}_{B/N} + \bm{r}'_{S/B} + \bm{\omega}_{B/N} \times \bm{r}_{S/B}
	\label{eq:rDot}
\end{equation}

But $\bm{r}'_{S/B}$ is $0$ because the sensor is assumed to be fixed relative to the body frame. Then,
\begin{equation}
\ddot{\bm{r}}_{S/N} = \ddot{\bm{r}}_{B/N} + \dot{\bm{\omega}}_{B/N} \times \bm{r}_{S/B} +  \bm{\omega}_{B/N} \times (\bm{\omega}_{B/N} \times \bm{r}_{S/B})
\end{equation}
The equation above is indeed the equation for the inertial acceleration of the sensor, but the sensor will only measure the non-conservative accelerations. To account for this, the equation is modified to be:
\begin{equation}
\ddot{\bm{r}}_{S/N, \textrm{sensed}} = (\ddot{\bm{r}}_{B/N} - \bm{a}_\textrm{g}) + \dot{\bm{\omega}}_{B/N} \times \bm{r}_{S/B} +  \bm{\omega}_{B/N} \times (\bm{\omega}_{B/N} \times \bm{r}_{S/B})
\end{equation}
where $\bm{a}_\textrm{g}$ is the instantaneous acceleration due to gravity. Conveniently, $\ddot{\bm{r}}_{B/N}$ is available directly from the spacecraft, but in the body frame. $\bm{r}_{S/B}$ is also available in the body frame. $\dot{\bm{\omega}}_{B/N}$ is given by the spacecraft in body frame coordinates as well. As such, the above equation is first evaluated in the body frame and then converted to the sensor platform frame, giving the acceleration sensed by the IMU in the IMU platform frame coordinates:
\begin{equation}
	^P\ddot{\bm{r}}_{S/N, \textrm{sensed}} = [PB] ^B \ddot{\bm{r}}_{S/N, \textrm{sensed}}
\end{equation}

\subsubsection{Change In Velocity}
The IMU also outputs the velocity accumulated between IMU calls. In order to avoid complexities having to do with the relative time step between the dynamics process and the IMU calls, this is not calculated in the same way as an IMU works physically. In this way, also, the dynamics do not have to be run at a fast enough rate for a physical IMU velocity accumulation to be simulated.

Differencing Eq. \ref{eq:rDot} with itself from time 1 to time 2 gives the equation:
\begin{equation}
	\Delta_{2/1} 	\dot{\bm{r}}_{S/N} = \Delta_{2/1} \dot{\bm{r}}_{B/N} + \Delta_{2/1} (\bm{\omega}_{B/N} \times \bm{r}_{S/B})
	\label{eq:DeltaVelocity}
\end{equation}
$\Delta_{2/1} \dot{\bm{r}}_{B/N}$ is calculated as the difference between the total change in velocity accumulated by the spacecraft body frame at time 2 minus the total change in velocity accumulated by the spacecraft body frame at time 1:
\begin{equation}
\Delta_{2/1} \dot{\bm{r}}_{B/N} = DV_{\textrm{body\_total},2} - DV_{\textrm{body\_total},1}
\end{equation}
The above $DV$ values are given by the spacecraft module in body frame coordinates. Then,
\begin{equation}
	\Delta_{2/1} (\bm{\omega}_{B/N} \times \bm{r}_{S/B}) = \bm{\omega}_{{B/N}_2} \times \bm{r}_{{S/B}_2} - \bm{\omega}_{{B/N}_1} \times \bm{r}_{{S/B}_1}
\end{equation}
It is again convenient to evaluate this expression in the body frame because $\bm{\omega}_{{B/N}}$ is given by the spacecraft in body frame coordinates, $\bm{r}_{S/B}$ is given in body frame coordinates, and $\bm{r}_{S/B}$ is time-invariant in the body frame. i.e.:
\begin{equation}
	\bm{r}_{{S/B}_1} = \bm{r}_{{S/B}_2} = \bm{r}_{S/B}
\end{equation}
At this point, Eq. \ref{eq:DeltaVelocity} is evaluated in the body frame and converted to the sensor platform frame:
\begin{equation}
^P \Delta_{2/1} 	\dot{\bm{r}}_{S/N} = [PB] ^B \Delta_{2/1} 	\dot{\bm{r}}_{S/N}
\end{equation}
This, the change in velocity sensed by the IMU between IMU calls in platform frame coordinates, is the change in velocity output from the model.

Finally, it should be noted that the values for body frame acceleration and angular acceleration are linear estimates made by the spacecraftPlus module. This is done by dividing the values of change in velocity and change in angular velocity (respectively) by the time step over which spacecraftPlus is integrating. The before and after values of velocity and angular velocity are before and after the most recent spacecraftPlus integration. While not precisely the current spacecraft acceleration (or angular acceleration), this is the most accurate data available without running the dynamics integration an extra time, which would be computationally costly.

\subsubsection{Error Modeling}
The state which the simulation records for the spacecraft prior to sending that state to the IMU module is considered to be "truth". So, to simulate the errors found in real instrumentation, errors are added to the "truth" values for any measurement, $\mathbf{m}_{\mathrm{truth}}$, that the IMU deals with.

\begin{equation}
\mathbf{m}_{\mathrm{measured}} = \mathbf{m}_{\mathrm{truth}} + \mathbf{e}_{\mathrm{noise}} + \mathbf{e}_{\mathrm{bias}}
\end{equation}


\subsubsection{Data Discretization}
Because sensors record data digitally, that data can only be recorded in discrete chunks, rather than the (relatively) continuous values that the computer calculates at each time steps. In order to simulation real IMU behavior in this way, a least significant bit (LSB) value is accepted for both the gyro and the accelerometer. This LSB is applied as follows to any 3-dimensional measurement $\mathbf{m}$:

\begin{equation}
\mathbf{m}_{\mathrm{discretized}} = (\mathrm{LSB})\Biggl\lfloor\Biggl|\frac{\mathbf{m}_{\mathrm{measured}}}{(\mathrm{LSB})}\Biggr|\Biggr\rfloor
\end{equation}

Where $\lfloor$  $\rfloor$ indicate the \textbf{floor()} function and LSB can be either the accelerometer or gyro least significant bit.

\subsubsection{Saturation}
Real sensors can also become saturated. This is modeled simply by comparing $\mathbf{m}_{\mathrm{discretized}}$ to the high and low saturation values for the sensor:

\begin{equation}
\mathbf{m}_{\mathrm{saturated}} = max\Big(\mathbf{m}_{\mathrm{sat,min}},\big(min(\mathbf{m}_{\mathrm{discretized}},\mathbf{m}_{\mathrm{sat,max}})\big)\Big)
\end{equation}

\noindent Note that this is actually only computed if $\mathbf{m}_{\mathrm{discretized}}$ proves to be outside of its saturation bounds.
