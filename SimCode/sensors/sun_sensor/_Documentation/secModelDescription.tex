% !TEX root = ./Basilisk-CoarseSunSensor-20170803.tex

\section{Model Description}

\begin{figure}[htb]
	\centerline{
		\includegraphics[]{Figures/moduleDiagram}
	}
	\caption{Illustration of the CoarseSunSensor() module I/O}
	\label{fig:moduleDiagram}
\end{figure}
\subsection{Overview}
This document describes how Coarse Sun Sensor (CSS) devices are modeled in the Basilisk software.  Each CSS is modeled through a nominal cosine response relative to the sunlight incidence angle.  This response can then be corrupted, or reduced due to being in a planet's shadow.  It is possible to add individual CSS sensors to the BSK evaluation stack.  However, it is typically simpler to use the {\tt CSSConstellation()} class to store a list of CSS units which are updated as a group, along with a unique CSS array output message.

\subsection{Single CSS module}
\subsubsection{I/O Messages}
First, let us discuss the input and output messages of the individual CSS sensor module.  The two required input messages are of the type {\tt SpicePlanetStateSimMsg} and {\tt SCPlusStatesSimMsg}.  The first message is used to determine the sun's location relative to the inertial frame $\leftexp{N}{\bm r}_{\sun/\mathcal{N}}$.  The second message is used to read in the spacecraft inertial position vector relative to the same inertial frame $\leftexp{N}{\bm r}_{\cal B/N}$.  Finally, the last message is optional.  If it is connected, it provides the sun shadow parameter indicating if the spacecraft is in a planet's shadow.  

The output message of an individual CSS unit creates a message containing the simulated CSS sensor.


\subsubsection{CSS Signal Simulation}
To evaluate the sun heading vector $\bm s$, the satellite and sun position vectors are used.
\begin{equation}
	\leftexp{N}{\bm s} = \leftexp{N}{\bm r}_{\sun/\mathcal{N}} - \leftexp{N}{\bm r}_{\cal B/N}
\end{equation}
After normalizing this vector to $\hat{\bm s}$ and mapping $\bm\sigma_{\cal B/N}$ to $[BN]$, it is mapped into body frame components through
\begin{equation}
	\leftexp{B}{\hat{\bm s}} = [BN] \leftexp{N}{\hat{\bm s}}
\end{equation}

The CSS sensor unit normal vector is given by $\leftexp{B}{\hat{\bm n}}$ in body frame components.  The normalized cosine sensor signal $\hat\gamma$ is thus determined through
\begin{equation}
	\hat \gamma = \hat{\bm n} \cdot \hat{\bm s} = \cos\phi
\end{equation}
where $\phi$ is the CSS sunlight incidence angle.  
This is the normalized CSS signal where 1 is returned if the sensor is looking straight at the sun.  If the sensor axis $\hat{\bm n}$ is more than the field of view half-angle (set through {\tt fov}) from the sun axis, then a 0 signal is simulated.  This {\tt fov} variable is the angle from $\hat{\bm n}$ beyond which the CSS signal is set to zero.  

Let $p_{s}$ be the local solar shadow parameter.  If the spacecraft is outside of a planet's shadow, this value is 1.  If it is within the shadow, then it is $0\le p_{s} < 1$.  The shadow adjusted CSS signal is thus computed as 
\begin{equation}
	\hat{\gamma}_{s} = \hat{\gamma} p_{s}
\end{equation}

%Let $p_{a}$ be the CSS normalized contribution due to the planet's albedo value, then the final true CSS signal is 
%\begin{equation}
%	\hat\gamma_{\text{true}} = \hat{\gamma}_{s} + p_{a}
%\end{equation}

To simulate CSS signal corruptions, then a Kelly curve corruption, a bias and a gaussian noise can be included.  The normalized bias is set through {\tt SenBias}, while the normalized noise is set through {\tt SenNoiseStd}.   Let $\bm p_{n}$ be the normalized sensor noise.  Note that this noise level is non-dimensional relative to the unit cosine curve.  Therefore, it will also be scaled when a scale factor is applied to the output.

\begin{figure}[htb]
	\centerline{
		\includegraphics[]{Figures/kelly}
	}
	\caption{Kelly distortion illustration with $\kappa = 0.1$}
	\label{fig:kelly}
\end{figure}
The Kelly corruption parameter allows for the CSS signal to pinch towards zero for larger incidence angles as illustrated in Figure~\ref{fig:kelly}.  The amount of signal distortion is set through $\kappa$, where the Kelly factor $p_{\kappa}$ is then computed as 
\begin{equation}
	p_{\kappa} = 1 - e^{-\hat\gamma_{s}^{2}/\kappa}
\end{equation}
The corrupted normalized CSS signal is then
\begin{equation}
	\hat \gamma_{c} = (\hat\gamma_{s} + p_{a}) p_{\kappa} + p_{n}
\end{equation}

At this point the signal shape is correct, but not the scale.  The final step is to scale.  Using the {\tt scaleFactor} $=\alpha$ parameter, the CSS signal is now scaled to a dimensional value.  
\begin{equation}
	\gamma = \hat{\gamma}_{c} \alpha
\end{equation}


\begin{figure}[htb]
	\centerline{
	\includegraphics[]{Figures/moduleDiagramConstellation}
	}
	\caption{Illustration of the CSS Constellation class}
	\label{fig:moduleDiagramConstellation}
\end{figure}
\subsection{Constellation or Array of CSS Modules}
The {\tt CSSConstellation} class is defined as a convenience such that the Basilisk update function is called on a group of CSS modules.  Here the CSS BSK modules are created and configured as before, but are then provided to the {\tt CSSConstellation} class object as a list of CSS in python.  The CSS can be configured individually, and must each be connected with the required input messages.  However, the {\tt CSSConstellation} will gather all the CSS outputs and write a single CSS Constellation output message of the type {\tt CSSArraySensorIntMsg} as shown in Figure~\ref{fig:moduleDiagramConstellation}.  



