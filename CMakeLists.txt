cmake_minimum_required(VERSION 2.8)

project("AVS basilisk")


#! make_python_package : create python package
#
# This function creates a python package directory and adds an __init__.py 
# file or copies an existing custom __init__.py file. A list of package 
# supporting files may be passed as the thried parameter. The function takes
# three arguments.
#
# \arg:FileBase the desired python package name
# \arg:FileDir the directory path relative to the cmake script calling the function
# \arg:moduleFilePath path to the Basilisk module's resulting python package directory 
#
function(make_python_package FileBase FileDir moduleFilePath)
    # Delete module folder and contents if it exists
	file(REMOVE_RECURSE "${CMAKE_SOURCE_DIR}/modules/${FileBase}")
	
	make_python_package_dir(${FileBase} ${FileDir})
	# Create symlinks in the python package directory to any 
	# Basilisk module supporting files. 
	file(GLOB supportingFiles 
		"${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/*.xml" 
		"${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/*.py")
	list(REMOVE_ITEM supportingFiles ${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/__init__.py)
	
	create_symlinks(${moduleFilePath} ${supportingFiles})
endfunction(make_python_package)


#! create_symlinks : create python package directory
#
# This function creates symlinks to supporting files for python packages. 
# The function takes one required argument and N optional arguments.
#
# \arg:destinationPath the desired location in which to create the symlinks
# \argn: a list of supporting file paths 
#
function(create_symlinks destinationPath)
    # Do nothing if building in-source
    if (${CMAKE_CURRENT_BINARY_DIR} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR})
        return()
    endif()
	#message(destinationPath: ${destinationPath})
	#message(ARGN: ${ARGN})
    foreach (filePath ${ARGN})
        get_filename_component(fileName ${filePath} NAME)
# message(${folder})
#         # Create REAL folder
#         file(MAKE_DIRECTORY "${destinationPath}/${folder}")
# message("directory created: ${destinationPath}/${folder}")
        # Delete symlink if it exists
        # file(REMOVE "${CMAKE_CURRENT_BINARY_DIR}/${path_file}")

        # Get OS dependent path to use in `execute_process`
        file(TO_NATIVE_PATH "${destinationPath}/${fileName}" link)
        file(TO_NATIVE_PATH "${filePath}" target)

        if (UNIX)
            set(command ln -s ${target} ${link})
        else()
            set(command cmd.exe /c mklink ${link} ${target})
        endif()

        execute_process(COMMAND ${command} 
                        RESULT_VARIABLE result
                        ERROR_VARIABLE output)

        if (NOT ${result} EQUAL 0)
        #    message(FATAL_ERROR "Could not create symbolic link for: ${target} --> ${output}")
        endif()

    endforeach(filePath)
endfunction(create_symlinks)


#! make_python_package_dir : create python package directory
#
# This function creates a python package directory and adds an __init__.py 
# file or copies an existing custom __init__.py file. The function takes
# two arguments.
#
# \arg:FileBase the desired python package name
# \arg:FileDir the directory path relative to the cmake script calling the function
#
function(make_python_package_dir FileBase FileDir)
	# message(FileBase: ${FileBase})
	# message(FileDir: ${FileDir})
	set(destination ${CMAKE_SOURCE_DIR}/modules/${FileBase})
    file(MAKE_DIRECTORY "${CMAKE_SOURCE_DIR}/modules/${FileBase}")
	if(NOT EXISTS "${FileDir}/__init__.py")
		file(WRITE "__init__.py" "# This __init__.py file for the ${FileBase} package is automatically generated by the build system 
from ${FileBase} import *")
		file(COPY "__init__.py" DESTINATION ${destination})
	else()
		configure_file(${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/__init__.py ${destination}/__init__.py COPYONLY)
	endif()
	if (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/__init__.py")
		file(REMOVE "__init__.py")
	endif()
endfunction(make_python_package_dir)

# Start of main projection configuration
find_package(PythonLibs 2.7 REQUIRED)
find_package(PythonInterp 2.7 REQUIRED)

# set(CMAKE_SWIG_OUTDIR ${CMAKE_SOURCE_DIR}/modules)

# Add general compiler flags
set(CMAKE_MACOSX_RPATH 1)
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2")

# Add platform specific compiler flags
set(Boost_USE_STATIC_LIBS ON)
set(Boost_USE_STATIC_RUNTIME ON)
if(MSVC)
    add_definitions(/D _CRT_SECURE_NO_WARNINGS)
    add_definitions(/D _WINSOCK_DEPRECATED_NO_WARNINGS)
    add_definitions(/D _WIN32_WINNT=0x0501) # Targets Windows xp
    add_definitions(/D BOOST_ALL_NO_LIB)
    add_definitions(/W3)
    add_definitions(/wd"4913")
    # Make sure we are using Multi-Threaded run time library
    foreach(flag 
        CMAKE_C_FLAGS
        CMAKE_C_FLAGS_DEBUG
        CMAKE_C_FLAGS_RELEASE
        CMAKE_CXX_FLAGS
        CMAKE_CXX_FLAGS_DEBUG
        CMAKE_CXX_FLAGS_RELEASE)
        string(REPLACE "/D_DEBUG" "" "${flag}" "${${flag}}")
        string(REPLACE "/MD" "/MT" "${flag}" "${${flag}}")
        string(REPLACE "/MDd" "/MT" "${flag}" "${${flag}}")
        string(REPLACE "/MTd" "/MT" "${flag}" "${${flag}}")
        set("${flag}" "${${flag}} /EHsc")
    endforeach()
elseif(APPLE)
	set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -gdwarf-3")
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -gdwarf-3 -std=c++11 -stdlib=libc++")
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -gdwarf-3")
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}  -Wall")
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}  -Wall")
else()
	set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -gdwarf-3")
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -gdwarf-3 -std=c++11 -fPIC")
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -gdwarf-3")
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}  -Wall")
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}  -Wall")
    set(Boost_USE_STATIC_LIBS OFF)
    set(Boost_USE_STATIC_RUNTIME OFF)

endif()

foreach( OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES} )
    string( TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG )
    set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_SOURCE_DIR}/modules )
    set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_SOURCE_DIR}/modules )
    set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_SOURCE_DIR}/modules )
endforeach( OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES )

# Add include directories
include_directories(SimCode)

# Set options used by "FindBoost.cmake".
# Either specify BOOST_ROOT or BOOST_INCLUDEDIR and BOOST_LIBRARYDIR.
#set (BOOST_INCLUDEDIR "External/boost_1_61_0/boost")
set(ENV{BOOST_ROOT} "External/boost_1_61_0")
set(BOOST_ROOT "External/boost_1_61_0")
set(Boost_NO_SYSTEM_PATHS ON)
set(Boost_USE_MULTITHREADED ON)
set(Boost_USE_DEBUG_RUNTIME OFF)

if(CMAKE_SIZEOF_VOID_P EQUAL 8)
  set(_arch_suffix 64)
else()
  set(_arch_suffix 32)
endif()

if("x${CMAKE_CXX_COMPILER_ID}" STREQUAL "xMSVC")
    if(NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 19)
      list(APPEND componentlibvar ${BOOST_ROOT}/lib${_arch_suffix}-msvc-14.0)
    elseif(NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 18)
      list(APPEND componentlibvar ${BOOST_ROOT}/lib${_arch_suffix}-msvc-12.0)
    elseif(NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 17)
      list(APPEND componentlibvar ${BOOST_ROOT}/lib${_arch_suffix}-msvc-11.0)
    elseif(NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 16)
      list(APPEND componentlibvar ${BOOST_ROOT}/lib${_arch_suffix}-msvc-10.0)
    elseif(NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 15)
      list(APPEND componentlibvar ${BOOST_ROOT}/lib${_arch_suffix}-msvc-9.0)
    elseif(NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 14)
      list(APPEND componentlibvar ${BOOST_ROOT}/lib${_arch_suffix}-msvc-8.0)
    endif()
elseif(APPLE)
	list(APPEND componentlibvar ${BOOST_ROOT}/lib${_arch_suffix}-osx)
elseif(UNIX)
	list(APPEND componentlibvar ${BOOST_ROOT}/lib${_arch_suffix}-unix)
endif()
set(BOOST_LIBRARYDIR ${CMAKE_SOURCE_DIR}/${componentlibvar})

# The components "system" and "filesystem" from "Boost" version 1.55.0 or
# greater are required.
find_package (Boost 1.61.0 REQUIRED COMPONENTS system filesystem serialization thread)

if (Boost_FOUND)
  # From the offical documentation:
  # Add include directories to the build. [...] If the SYSTEM option is given,
  # the compiler will be told the directories are meant as system include
  # directories on some platforms (signalling this setting might achieve effects
  # such as the compiler skipping warnings [...])."
  include_directories (SYSTEM ${Boost_INCLUDE_DIR})

  # From the offical documentation:
  # "Specify directories in which the linker will look for libraries. [...] Note
  # that this command is rarely necessary. Library locations returned by
  # find_package() and find_library() are absolute paths. Pass these absolute
  # library file paths directly to the target_link_libraries() command. CMake
  # will ensure the linker finds them."
  link_directories (${Boost_LIBRARY_DIRS})
endif ()

# Manually create list of libraries depending on system
if(WIN32)
	set(library_dependencies 
      	${CMAKE_SOURCE_DIR}/External/cspice/lib/cspice.lib
		${Boost_LIBRARIES}
	)
elseif(APPLE)
	set(library_dependencies 
		${CMAKE_SOURCE_DIR}/External/cspice/lib/cspice_osx.a
		${Boost_LIBRARIES}
		# ${CMAKE_SOURCE_DIR}/External/boost_1_61_0/lib64-osx/libboost_system.a
# 		${CMAKE_SOURCE_DIR}/External/boost_1_61_0/lib64-osx/libboost_serialization.a
# 		${CMAKE_SOURCE_DIR}/External/boost_1_61_0/lib64-osx/libboost_filesystem.a
#${CMAKE_SOURCE_DIR}/External/boost_1_61_0/lib64-osx/libboost_thread.a
	)
   	#set(CMAKE_INSTALL_RPATH "@rpath/../modules")
	# use, i.e. don't skip the full RPATH for the build tree
	SET(CMAKE_SKIP_BUILD_RPATH  FALSE)

	# when building, don't use the install RPATH already
	# (but later on when installing)
	SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE) 

	# the RPATH to be used when installing
	SET(CMAKE_INSTALL_RPATH "${CMAKE_SOURCE_DIR}/modules")

	# don't add the automatically determined parts of the RPATH
	# which point to directories outside the build tree to the install RPATH
	SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)	
else()
	set(library_dependencies
		${CMAKE_SOURCE_DIR}/External/cspice/lib/cspice.a
		${Boost_LIBRARIES}
	)
	set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)
	set(CMAKE_INSTALL_RPATH "\$ORIGIN/../")
endif()

set_property(GLOBAL PROPERTY BUILT_LIB_LIST "SimUtilities;SimMessaging")
set_property(GLOBAL PROPERTY ALG_LIB_LIST "AlgorithmMessaging")
set_property(GLOBAL PROPERTY USE_FOLDERS ON)

add_subdirectory("SimCode/utilities")
add_subdirectory("SimCode/architecture/messaging")
add_subdirectory("SimCode")
add_subdirectory("ADCSAlgorithms/messaging")
add_subdirectory("ADCSAlgorithms")
add_subdirectory("Utilities/pyswice")

#find_package(Doxygen)
#if(DOXYGEN_FOUND)
#   add_custom_target(ScriptRun ALL
#                   COMMAND ${DOXYGEN_EXECUTABLE} ${CMAKE_SOURCE_DIR}/DoxyData)
#endif(DOXYGEN_FOUND)
